<?xml version="1.0"?>
<root>
  <ModuleHolder ModuleName="--Kernel tables" File="">
    <BlockHolder BlockName="--body" BlockCode=" 

-- kernel tables --
create table if not exists sysoptions(
sysoptionsid binary(16) primary key ,
name varchar(255) null,
value varchar(255) null,
optiontype varchar(255) null
)
go
create table if not exists typelist(
typelistid binary(16) primary key ,
name varchar(255) not null,
securitystyleid binary(16) null, /* default security style for type */
registerproc varchar(255) null,
deleteproc varchar(255) null,
hclproc varchar(255) null /* has children locked */,
propagateproc varchar(255) null /* propagate secrity styleto children */
)
go
create table if not exists instance(
instanceid binary(16) primary key ,
lockuserid binary(16) null, 
locksessionid binary(16) null, 
securitystyleid binary(16) null, /* default security style for document */
changestamp date null,
name varchar(255) null,
objtype varchar(255) null,
exportcounter integer null, 
 ownerpartname varchar(255) null
,ownerrowid binary(16) null
, status binary(16) null
, archived int null default 0
)
go
create table if not exists queryresult (
  queryresultid binary(16) not null ,
  result binary(16) null 
)
go
create table if not exists rpresult (
  rpresultid binary(16) not null ,
  parentlevel int not null ,
  partname varchar (255) null ,
  rowid binary(16) null )
go
">
      <FormData Name="" />
    </BlockHolder>
  </ModuleHolder>
  <ModuleHolder ModuleName="--Tables" File="">
    <BlockHolder BlockName="--body" BlockCode=" 
/* TYPE=bp3ft () */
GO

/*тип поля*/
create table if not exists bp3ft_def/*тип полея, перечисления, интервалы*/ (
instanceid binary(16) ,
bp3ft_defid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3ft_def' and 
           column_name   = 'delayedsave') then
                alter table bp3ft_def add 
                delayedsave
 integer null /* отложенное сохранение */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3ft_def' and 
           column_name   = 'typestyle') then
                alter table bp3ft_def add 
                typestyle
 integer null /* трактовка */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3ft_def' and 
           column_name   = 'name') then
                alter table bp3ft_def add 
                name
 varchar (255) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3ft_def' and 
           column_name   = 'gridsorttype') then
                alter table bp3ft_def add 
                gridsorttype
 integer null /* вариант сортировки в табличном представлении */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3ft_def' and 
           column_name   = 'the_comment') then
                alter table bp3ft_def add 
                the_comment
 text null /* описание */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3ft_def' and 
           column_name   = 'allowsize') then
                alter table bp3ft_def add 
                allowsize
 integer null /* нужен размер */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3ft_def' and 
           column_name   = 'allowlikesearch') then
                alter table bp3ft_def add 
                allowlikesearch
 integer null /* поиск текста */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3ft_def' and 
           column_name   = 'maximum') then
                alter table bp3ft_def add 
                maximum
 varchar (64) null /* максимум */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3ft_def' and 
           column_name   = 'minimum') then
                alter table bp3ft_def add 
                minimum
 varchar (64) null /* минимум */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'bp3ft_def' and 
           constraint_type   = 'primary key') then
            alter table bp3ft_def add constraint pk_bp3ft_def primary key (bp3ft_defid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*отображение*/
create table if not exists bp3ft_map/*отображение типа поля на физический тип хранения*/ (
instanceid binary(16) ,
bp3ft_mapid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3ft_map' and 
           column_name   = 'fixedsize') then
                alter table bp3ft_map add 
                fixedsize
 integer null /* размер */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3ft_map' and 
           column_name   = 'stoagetype') then
                alter table bp3ft_map add 
                stoagetype
 varchar (255) null /* тип хранения */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3ft_map' and 
           column_name   = 'target') then
                alter table bp3ft_map add 
                target binary(16) null /* платформа */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'bp3ft_map' and 
           constraint_type   = 'primary key') then
            alter table bp3ft_map add constraint pk_bp3ft_map primary key (bp3ft_mapid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*зачения*/
create table if not exists bp3ft_enums/*для описания enum типов*/ (
instanceid binary(16) ,
bp3ft_enumsid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3ft_enums' and 
           column_name   = 'name') then
                alter table bp3ft_enums add 
                name
 varchar (255) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3ft_enums' and 
           column_name   = 'nameincode') then
                alter table bp3ft_enums add 
                nameincode
 varchar (100) null /* название в коде */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3ft_enums' and 
           column_name   = 'namevalue') then
                alter table bp3ft_enums add 
                namevalue
 integer null /* значение */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'bp3ft_enums' and 
           constraint_type   = 'primary key') then
            alter table bp3ft_enums add constraint pk_bp3ft_enums primary key (bp3ft_enumsid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=bp3app () */
GO

/*модули*/
create table if not exists bp3app_modules/*пункты главного меню*/ (
instanceid binary(16) ,
bp3app_modulesid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3app_modules' and 
           column_name   = 'topmenu') then
                alter table bp3app_modules add 
                topmenu binary(16) null /* меню */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3app_modules' and 
           column_name   = 'groupname') then
                alter table bp3app_modules add 
                groupname
 varchar (60) null /* имя группы */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3app_modules' and 
           column_name   = 'caption') then
                alter table bp3app_modules add 
                caption
 varchar (80) null /* надпись */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3app_modules' and 
           column_name   = 'name') then
                alter table bp3app_modules add 
                name
 varchar (64) null /* код модуля */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3app_modules' and 
           column_name   = 'sequence') then
                alter table bp3app_modules add 
                sequence
 integer null /* № п/п */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3app_modules' and 
           column_name   = 'thecomment') then
                alter table bp3app_modules add 
                thecomment
 text null /* описание */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3app_modules' and 
           column_name   = 'theicon') then
                alter table bp3app_modules add 
                theicon
 varchar (64) null /* иконка */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3app_modules' and 
           column_name   = 'customizevisibility') then
                alter table bp3app_modules add 
                customizevisibility
 integer null /* настраивать видимость */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3app_modules' and 
           column_name   = 'journal') then
                alter table bp3app_modules add 
                journal binary(16) null /* журнал */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3app_modules' and 
           column_name   = 'document') then
                alter table bp3app_modules add 
                document binary(16) null /* документ */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3app_modules' and 
           column_name   = 'actiontype') then
                alter table bp3app_modules add 
                actiontype
 integer null /* вариант действия */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3app_modules' and 
           column_name   = 'objecttype') then
                alter table bp3app_modules add 
                objecttype binary(16) null /* тип документа */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3app_modules' and 
           column_name   = 'report') then
                alter table bp3app_modules add 
                report binary(16) null /* отчет */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'bp3app_modules' and 
           constraint_type   = 'primary key') then
            alter table bp3app_modules add constraint pk_bp3app_modules primary key (bp3app_modulesid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*действия и отчеты*/
create table if not exists bp3app_oper/*действия и отчеты*/ (
parentstructrowid binary(16) not null,
bp3app_operid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3app_oper' and 
           column_name   = 'righttype') then
                alter table bp3app_oper add 
                righttype binary(16) null /* тип права */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3app_oper' and 
           column_name   = 'caption') then
                alter table bp3app_oper add 
                caption
 varchar (80) null /* надпись */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3app_oper' and 
           column_name   = 'name') then
                alter table bp3app_oper add 
                name
 varchar (64) null /* код */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3app_oper' and 
           column_name   = 'sequence') then
                alter table bp3app_oper add 
                sequence
 integer null /* № п/п */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3app_oper' and 
           column_name   = 'theicon') then
                alter table bp3app_oper add 
                theicon
 varchar (64) null /* иконка */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3app_oper' and 
           column_name   = 'isreport') then
                alter table bp3app_oper add 
                isreport
 integer null /* это отчет */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'bp3app_oper' and 
           constraint_type   = 'primary key') then
            alter table bp3app_oper add constraint pk_bp3app_oper primary key (bp3app_operid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*меню*/
create table if not exists bp3app_menu/**/ (
instanceid binary(16) ,
bp3app_menuid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3app_menu' and 
           column_name   = 'caption') then
                alter table bp3app_menu add 
                caption
 varchar (80) null /* надпись */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3app_menu' and 
           column_name   = 'name') then
                alter table bp3app_menu add 
                name
 varchar (64) null /* код модуля */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3app_menu' and 
           column_name   = 'sequence') then
                alter table bp3app_menu add 
                sequence
 integer null /* № п/п */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3app_menu' and 
           column_name   = 'theicon') then
                alter table bp3app_menu add 
                theicon
 varchar (64) null /* иконка */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'bp3app_menu' and 
           constraint_type   = 'primary key') then
            alter table bp3app_menu add constraint pk_bp3app_menu primary key (bp3app_menuid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*тип права*/
create table if not exists bp3app_rigthtype/*тип права*/ (
instanceid binary(16) ,
bp3app_rigthtypeid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3app_rigthtype' and 
           column_name   = 'name') then
                alter table bp3app_rigthtype add 
                name
 varchar (50) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3app_rigthtype' and 
           column_name   = 'listsortorder') then
                alter table bp3app_rigthtype add 
                listsortorder
 integer null /* порядок вывода */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3app_rigthtype' and 
           column_name   = 'shortname') then
                alter table bp3app_rigthtype add 
                shortname
 varchar (20) null /* краткое название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3app_rigthtype' and 
           column_name   = 'selecttype') then
                alter table bp3app_rigthtype add 
                selecttype
 integer null /* вариант выбора */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'bp3app_rigthtype' and 
           constraint_type   = 'primary key') then
            alter table bp3app_rigthtype add constraint pk_bp3app_rigthtype primary key (bp3app_rigthtypeid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*описание*/
create table if not exists bp3app_info/**/ (
instanceid binary(16) ,
bp3app_infoid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3app_info' and 
           column_name   = 'name') then
                alter table bp3app_info add 
                name
 varchar (120) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3app_info' and 
           column_name   = 'version') then
                alter table bp3app_info add 
                version
 integer null /* версия */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'bp3app_info' and 
           constraint_type   = 'primary key') then
            alter table bp3app_info add constraint pk_bp3app_info primary key (bp3app_infoid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=bp3list () */
GO

/*колонки журнала*/
create table if not exists bp3list_col/*колонки журнала*/ (
instanceid binary(16) ,
bp3list_colid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3list_col' and 
           column_name   = 'columnalignment') then
                alter table bp3list_col add 
                columnalignment
 integer null /* выравнивание */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3list_col' and 
           column_name   = 'groupaggregation') then
                alter table bp3list_col add 
                groupaggregation
 integer null /* аггрегация при группировке */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3list_col' and 
           column_name   = 'name') then
                alter table bp3list_col add 
                name
 varchar (255) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3list_col' and 
           column_name   = 'colsort') then
                alter table bp3list_col add 
                colsort
 integer null /* сортировка колонки */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3list_col' and 
           column_name   = 'sequence') then
                alter table bp3list_col add 
                sequence
 integer null /* последовательность */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3list_col' and 
           column_name   = 'colwidth') then
                alter table bp3list_col add 
                colwidth
 integer null /* ширина колонки */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3list_col' and 
           column_name   = 'thestyle') then
                alter table bp3list_col add 
                thestyle
 varchar (255) null /* стиль */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'bp3list_col' and 
           constraint_type   = 'primary key') then
            alter table bp3list_col add constraint pk_bp3list_col primary key (bp3list_colid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*состав колонки*/
create table if not exists bp3list_colsrc/*состав колонки*/ (
parentstructrowid binary(16) not null,
bp3list_colsrcid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3list_colsrc' and 
           column_name   = 'viewfield') then
                alter table bp3list_colsrc add 
                viewfield
 varchar (255) null /* поле представления */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3list_colsrc' and 
           column_name   = 'srcpartview') then
                alter table bp3list_colsrc add 
                srcpartview binary(16) null /* представление */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'bp3list_colsrc' and 
           constraint_type   = 'primary key') then
            alter table bp3list_colsrc add constraint pk_bp3list_colsrc primary key (bp3list_colsrcid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*журнал*/
create table if not exists bp3list_def/*журнал*/ (
instanceid binary(16) ,
bp3list_defid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3list_def' and 
           column_name   = 'name') then
                alter table bp3list_def add 
                name
 varchar (255) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3list_def' and 
           column_name   = 'thecomment') then
                alter table bp3list_def add 
                thecomment
 text null /* описание */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3list_def' and 
           column_name   = 'sourceview') then
                alter table bp3list_def add 
                sourceview binary(16) null /* запрос */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3list_def' and 
           column_name   = 'onrun') then
                alter table bp3list_def add 
                onrun
 integer null /* при открытии */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3list_def' and 
           column_name   = 'editcard') then
                alter table bp3list_def add 
                editcard binary(16) null /* карточка для редактирования */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3list_def' and 
           column_name   = 'newcard') then
                alter table bp3list_def add 
                newcard binary(16) null /* карточка для создания */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'bp3list_def' and 
           constraint_type   = 'primary key') then
            alter table bp3list_def add constraint pk_bp3list_def primary key (bp3list_defid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*группа полей фильтра*/
create table if not exists bp3list_filter/*группа полей фильтра*/ (
instanceid binary(16) ,
bp3list_filterid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3list_filter' and 
           column_name   = 'caption') then
                alter table bp3list_filter add 
                caption
 varchar (255) null /* заголовок */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3list_filter' and 
           column_name   = 'sequence') then
                alter table bp3list_filter add 
                sequence
 integer null /* последовательность */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3list_filter' and 
           column_name   = 'name') then
                alter table bp3list_filter add 
                name
 varchar (64) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3list_filter' and 
           column_name   = 'allowignore') then
                alter table bp3list_filter add 
                allowignore
 integer null /* можно отключать */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'bp3list_filter' and 
           constraint_type   = 'primary key') then
            alter table bp3list_filter add constraint pk_bp3list_filter primary key (bp3list_filterid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*поле фильтра*/
create table if not exists bp3list_filterfield/*поле фильтра*/ (
parentstructrowid binary(16) not null,
bp3list_filterfieldid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3list_filterfield' and 
           column_name   = 'fieldsize') then
                alter table bp3list_filterfield add 
                fieldsize
 integer null /* размер */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3list_filterfield' and 
           column_name   = 'reftype') then
                alter table bp3list_filterfield add 
                reftype
 integer null /* тип ссылки */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3list_filterfield' and 
           column_name   = 'caption') then
                alter table bp3list_filterfield add 
                caption
 varchar (255) null /* заголовок */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3list_filterfield' and 
           column_name   = 'name') then
                alter table bp3list_filterfield add 
                name
 varchar (255) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3list_filterfield' and 
           column_name   = 'fieldtype') then
                alter table bp3list_filterfield add 
                fieldtype binary(16) null /* тип поля */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3list_filterfield' and 
           column_name   = 'valuearray') then
                alter table bp3list_filterfield add 
                valuearray
 integer null /* массив значений */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3list_filterfield' and 
           column_name   = 'sequence') then
                alter table bp3list_filterfield add 
                sequence
 integer null /* последовательность */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3list_filterfield' and 
           column_name   = 'reftopart') then
                alter table bp3list_filterfield add 
                reftopart binary(16) null /* раздел, куда ссылаемся */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'bp3list_filterfield' and 
           constraint_type   = 'primary key') then
            alter table bp3list_filterfield add constraint pk_bp3list_filterfield primary key (bp3list_filterfieldid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=MTZSystem (Документ заполняется системой автоматически. Он содержит журнал активности пользователей системы, в который заносится вся информация о действиях пользователей.) */
GO

/*сессия пользователя*/
create table if not exists the_session/*зарегистрированные сессии пользователей*/ (
instanceid binary(16) ,
the_sessionid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'the_session' and 
           column_name   = 'applicationid') then
                alter table the_session add 
                applicationid binary(16) null /* приложение */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'the_session' and 
           column_name   = 'userrole') then
                alter table the_session add 
                userrole binary(16) null /* текущая роль пользователя */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'the_session' and 
           column_name   = 'closedat') then
                alter table the_session add 
                closedat
 datetime null /* момент закрытия */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'the_session' and 
           column_name   = 'closed') then
                alter table the_session add 
                closed
 integer null /* закрыта */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'the_session' and 
           column_name   = 'usersid') then
                alter table the_session add 
                usersid binary(16) null /* пользователь */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'the_session' and 
           column_name   = 'lastaccess') then
                alter table the_session add 
                lastaccess
 datetime null /* последнее подтверждение */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'the_session' and 
           column_name   = 'startat') then
                alter table the_session add 
                startat
 datetime null /* момент открытия */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'the_session' and 
           column_name   = 'lang') then
                alter table the_session add 
                lang
 varchar (25) null /* локализация */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'the_session' and 
           column_name   = 'login') then
                alter table the_session add 
                login
 varchar (255) null /* login */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'the_session' and 
           constraint_type   = 'primary key') then
            alter table the_session add constraint pk_the_session primary key (the_sessionid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*разрешенные владельцы*/
create table if not exists sysrefcache/*владельцы информации для к объектам которых
разрешен достуа для  текущей сесии*/ (
instanceid binary(16) ,
sysrefcacheid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'sysrefcache' and 
           column_name   = 'cachetype') then
                alter table sysrefcache add 
                cachetype
 integer null /* тип кеширования */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'sysrefcache' and 
           column_name   = 'objectownerid') then
                alter table sysrefcache add 
                objectownerid binary(16) null /* идентификатор владельца */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'sysrefcache' and 
           column_name   = 'sessionid') then
                alter table sysrefcache add 
                sessionid binary(16) null /* сессия */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'sysrefcache' and 
           column_name   = 'themarket') then
                alter table sysrefcache add 
                themarket
 integer null /* рынок */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'sysrefcache' and 
           constraint_type   = 'primary key') then
            alter table sysrefcache add constraint pk_sysrefcache primary key (sysrefcacheid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*журнал событий*/
create table if not exists syslog/*журнал событий, которые произошли в системе*/ (
instanceid binary(16) ,
syslogid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'syslog' and 
           column_name   = 'thesession') then
                alter table syslog add 
                thesession binary(16) null /* сессия */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'syslog' and 
           column_name   = 'the_resource') then
                alter table syslog add 
                the_resource
 varchar (255) null /* ресурс */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'syslog' and 
           column_name   = 'logstructid') then
                alter table syslog add 
                logstructid
 varchar (255) null /* раздел с которым происхоит действие */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'syslog' and 
           column_name   = 'verb') then
                alter table syslog add 
                verb
 varchar (80) null /* действие */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'syslog' and 
           column_name   = 'loginstanceid') then
                alter table syslog add 
                loginstanceid binary(16) null /* идентификатор документа */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'syslog' and 
           constraint_type   = 'primary key') then
            alter table syslog add constraint pk_syslog primary key (syslogid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=bp3qry () */
GO

/*колонка*/
create table if not exists bp3qry_column/*колонка пердставления*/ (
instanceid binary(16) ,
bp3qry_columnid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3qry_column' and 
           column_name   = 'forcombo') then
                alter table bp3qry_column add 
                forcombo
 integer null /* для комбо */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3qry_column' and 
           column_name   = 'frompart') then
                alter table bp3qry_column add 
                frompart binary(16) null /* раздел */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3qry_column' and 
           column_name   = 'aggregation') then
                alter table bp3qry_column add 
                aggregation
 integer null /* агрегация */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3qry_column' and 
           column_name   = 'sequence') then
                alter table bp3qry_column add 
                sequence
 integer null /* № */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3qry_column' and 
           column_name   = 'the_alias') then
                alter table bp3qry_column add 
                the_alias
 varchar (64) null /* псвдоним */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3qry_column' and 
           column_name   = 'name') then
                alter table bp3qry_column add 
                name
 varchar (255) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3qry_column' and 
           column_name   = 'field') then
                alter table bp3qry_column add 
                field binary(16) null /* поле */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3qry_column' and 
           column_name   = 'expression') then
                alter table bp3qry_column add 
                expression
 text null /* формула */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'bp3qry_column' and 
           constraint_type   = 'primary key') then
            alter table bp3qry_column add constraint pk_bp3qry_column primary key (bp3qry_columnid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*представление*/
create table if not exists bp3qry_def/*вариант представления, который может использоваться для создания журнала*/ (
instanceid binary(16) ,
bp3qry_defid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3qry_def' and 
           column_name   = 'the_alias') then
                alter table bp3qry_def add 
                the_alias
 varchar (64) null /* псевдоним */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3qry_def' and 
           column_name   = 'forchoose') then
                alter table bp3qry_def add 
                forchoose
 integer null /* для поиска */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3qry_def' and 
           column_name   = 'name') then
                alter table bp3qry_def add 
                name
 varchar (255) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'bp3qry_def' and 
           constraint_type   = 'primary key') then
            alter table bp3qry_def add constraint pk_bp3qry_def primary key (bp3qry_defid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*связанные представления*/
create table if not exists bp3qry_link/*связанные представления*/ (
instanceid binary(16) ,
bp3qry_linkid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3qry_link' and 
           column_name   = 'thejoindestination') then
                alter table bp3qry_link add 
                thejoindestination binary(16) null /* свзяь: поле для join приемник */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3qry_link' and 
           column_name   = 'handjoin') then
                alter table bp3qry_link add 
                handjoin
 varchar (255) null /* ручной join */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3qry_link' and 
           column_name   = 'seq') then
                alter table bp3qry_link add 
                seq
 integer null /* порядок */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3qry_link' and 
           column_name   = 'thejoinsource') then
                alter table bp3qry_link add 
                thejoinsource binary(16) null /* связь: поле для join источник */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3qry_link' and 
           column_name   = 'theview') then
                alter table bp3qry_link add 
                theview binary(16) null /* представление */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3qry_link' and 
           column_name   = 'reftype') then
                alter table bp3qry_link add 
                reftype
 integer null /* связывать как */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'bp3qry_link' and 
           constraint_type   = 'primary key') then
            alter table bp3qry_link add constraint pk_bp3qry_link primary key (bp3qry_linkid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=MTZUsers (Документ содержит списки пользователей и состав групп пользователей системы.) */
GO

/*пользователи*/
create table if not exists users/*пользователи*/ (
instanceid binary(16) ,
usersid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'users' and 
           column_name   = 'family') then
                alter table users add 
                family
 varchar (255) null /* фамилия */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'users' and 
           column_name   = 'name') then
                alter table users add 
                name
 varchar (64) null /* имя */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'users' and 
           column_name   = 'surname') then
                alter table users add 
                surname
 varchar (255) null /* отчество */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'users' and 
           column_name   = 'login') then
                alter table users add 
                login
 varchar (64) null /* имя для входа */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'users' and 
           column_name   = 'password') then
                alter table users add 
                password varchar(80) null /* пароль */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'users' and 
           column_name   = 'domainame') then
                alter table users add 
                domainame
 varchar (255) null /* доменное имя */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'users' and 
           column_name   = 'email') then
                alter table users add 
                email varchar(255) null /* e-mail */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'users' and 
           column_name   = 'phone') then
                alter table users add 
                phone
 varchar (20) null /* телефон */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'users' and 
           column_name   = 'localphone') then
                alter table users add 
                localphone
 varchar (20) null /* местный телефон */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'users' and 
           constraint_type   = 'primary key') then
            alter table users add constraint pk_users primary key (usersid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*группы*/
create table if not exists groups/*группы*/ (
instanceid binary(16) ,
groupsid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'groups' and 
           column_name   = 'name') then
                alter table groups add 
                name
 varchar (80) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'groups' and 
           column_name   = 'adgroup') then
                alter table groups add 
                adgroup
 varchar (255) null /* группа ad */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'groups' and 
           constraint_type   = 'primary key') then
            alter table groups add constraint pk_groups primary key (groupsid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*состав группы*/
create table if not exists groupuser/*состав группы*/ (
parentstructrowid binary(16) not null,
groupuserid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'groupuser' and 
           column_name   = 'theuser') then
                alter table groupuser add 
                theuser binary(16) null /* пользователь */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'groupuser' and 
           constraint_type   = 'primary key') then
            alter table groupuser add constraint pk_groupuser primary key (groupuserid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=bp3dic () */
GO

/*генераторы*/
create table if not exists bp3dic_gen/*генераторы*/ (
instanceid binary(16) ,
bp3dic_genid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3dic_gen' and 
           column_name   = 'name') then
                alter table bp3dic_gen add 
                name
 varchar (255) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3dic_gen' and 
           column_name   = 'generatorstyle') then
                alter table bp3dic_gen add 
                generatorstyle
 integer null /* вариант */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3dic_gen' and 
           column_name   = 'queuename') then
                alter table bp3dic_gen add 
                queuename
 varchar (255) null /* очередь */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3dic_gen' and 
           column_name   = 'thedevelopmentenv') then
                alter table bp3dic_gen add 
                thedevelopmentenv
 integer null /* среда разработки */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3dic_gen' and 
           column_name   = 'generatorprogid') then
                alter table bp3dic_gen add 
                generatorprogid
 varchar (255) null /* com класс */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3dic_gen' and 
           column_name   = 'targettype') then
                alter table bp3dic_gen add 
                targettype
 integer null /* тип платформы */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'bp3dic_gen' and 
           constraint_type   = 'primary key') then
            alter table bp3dic_gen add constraint pk_bp3dic_gen primary key (bp3dic_genid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=bp3card (Карточка документа) */
GO

/*раздел*/
create table if not exists bp3card_part/*разделы документа*/ (
instanceid binary(16) ,
bp3card_partid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3card_part' and 
           column_name   = 'allowadd') then
                alter table bp3card_part add 
                allowadd
 integer null /* разрешено добавлять */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3card_part' and 
           column_name   = 'allowdelete') then
                alter table bp3card_part add 
                allowdelete
 integer null /* разрешено удалять */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3card_part' and 
           column_name   = 'allowread') then
                alter table bp3card_part add 
                allowread
 integer null /* разрешен просмотр */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3card_part' and 
           column_name   = 'struct') then
                alter table bp3card_part add 
                struct binary(16) null /* структура, доступ к которой ограничен */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3card_part' and 
           column_name   = 'allowedit') then
                alter table bp3card_part add 
                allowedit
 integer null /* разрешено изменять */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3card_part' and 
           column_name   = 'sequence') then
                alter table bp3card_part add 
                sequence
 integer null /* № п/п */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3card_part' and 
           column_name   = 'caption') then
                alter table bp3card_part add 
                caption
 varchar (255) null /* заголовок */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'bp3card_part' and 
           constraint_type   = 'primary key') then
            alter table bp3card_part add constraint pk_bp3card_part primary key (bp3card_partid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*поля карточки*/
create table if not exists bp3card_fld/*поля раздела*/ (
instanceid binary(16) ,
bp3card_fldid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3card_fld' and 
           column_name   = 'sequence') then
                alter table bp3card_fld add 
                sequence
 integer null /* № п/п */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3card_fld' and 
           column_name   = 'mandatoryfield') then
                alter table bp3card_fld add 
                mandatoryfield
 integer null /* обязательное поле */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3card_fld' and 
           column_name   = 'thefield') then
                alter table bp3card_fld add 
                thefield binary(16) null /* поле, на которое накладывается ограничение */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3card_fld' and 
           column_name   = 'thepart') then
                alter table bp3card_fld add 
                thepart binary(16) null /* структура, которой принадлежит поле */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3card_fld' and 
           column_name   = 'allowmodify') then
                alter table bp3card_fld add 
                allowmodify
 integer null /* разрешена модификация */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3card_fld' and 
           column_name   = 'allowread') then
                alter table bp3card_fld add 
                allowread
 integer null /* разрешен просмотр */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3card_fld' and 
           column_name   = 'tabname') then
                alter table bp3card_fld add 
                tabname
 varchar (60) null /* имя вкладки */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3card_fld' and 
           column_name   = 'fieldgroupbox') then
                alter table bp3card_fld add 
                fieldgroupbox
 varchar (60) null /* имя группы */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3card_fld' and 
           column_name   = 'thestyle') then
                alter table bp3card_fld add 
                thestyle
 varchar (50) null /* стиль */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3card_fld' and 
           column_name   = 'caption') then
                alter table bp3card_fld add 
                caption
 varchar (80) null /* надпись */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'bp3card_fld' and 
           constraint_type   = 'primary key') then
            alter table bp3card_fld add constraint pk_bp3card_fld primary key (bp3card_fldid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*карточка документа*/
create table if not exists bp3card_def/*карточка документа*/ (
instanceid binary(16) ,
bp3card_defid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3card_def' and 
           column_name   = 'cardfor') then
                alter table bp3card_def add 
                cardfor binary(16) null /* документ */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3card_def' and 
           column_name   = 'thecomment') then
                alter table bp3card_def add 
                thecomment
 text null /* описание */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3card_def' and 
           column_name   = 'name') then
                alter table bp3card_def add 
                name
 varchar (5) null /* название режима */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3card_def' and 
           column_name   = 'defaultmode') then
                alter table bp3card_def add 
                defaultmode
 integer null /* этот режим является основным режимом работы объекта */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3card_def' and 
           column_name   = 'cardiconcls') then
                alter table bp3card_def add 
                cardiconcls
 varchar (1) null /* иконка карточки */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'bp3card_def' and 
           constraint_type   = 'primary key') then
            alter table bp3card_def add constraint pk_bp3card_def primary key (bp3card_defid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=bp3doc () */
GO

/*ограничение уникальности*/
create table if not exists bp3doc_uk/*ограничение уникальности*/ (
instanceid binary(16) ,
bp3doc_ukid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3doc_uk' and 
           column_name   = 'thecomment') then
                alter table bp3doc_uk add 
                thecomment
 text null /* описание */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3doc_uk' and 
           column_name   = 'name') then
                alter table bp3doc_uk add 
                name
 varchar (80) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3doc_uk' and 
           column_name   = 'perparent') then
                alter table bp3doc_uk add 
                perparent
 integer null /* по родителю */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'bp3doc_uk' and 
           constraint_type   = 'primary key') then
            alter table bp3doc_uk add constraint pk_bp3doc_uk primary key (bp3doc_ukid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*поля ограничения*/
create table if not exists bp3doc_ukfld/*поля ограничения*/ (
parentstructrowid binary(16) not null,
bp3doc_ukfldid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3doc_ukfld' and 
           column_name   = 'thefield') then
                alter table bp3doc_ukfld add 
                thefield binary(16) null /* поле */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'bp3doc_ukfld' and 
           constraint_type   = 'primary key') then
            alter table bp3doc_ukfld add constraint pk_bp3doc_ukfld primary key (bp3doc_ukfldid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*раздел*/
create table if not exists bp3doc_store/*раздел объекта*/ (
instanceid binary(16) ,
bp3doc_storeid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
,parentrowid binary(16) 
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3doc_store' and 
           column_name   = 'sequence') then
                alter table bp3doc_store add 
                sequence
 integer null /* № п/п */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3doc_store' and 
           column_name   = 'caption') then
                alter table bp3doc_store add 
                caption
 varchar (255) null /* заголовок */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3doc_store' and 
           column_name   = 'parttype') then
                alter table bp3doc_store add 
                parttype
 integer null /* тип структры */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3doc_store' and 
           column_name   = 'name') then
                alter table bp3doc_store add 
                name
 varchar (20) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3doc_store' and 
           column_name   = 'the_comment') then
                alter table bp3doc_store add 
                the_comment
 text null /* описание */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3doc_store' and 
           column_name   = 'isdocinstance') then
                alter table bp3doc_store add 
                isdocinstance
 integer null /* главный раздел */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3doc_store' and 
           column_name   = 'usearchiving') then
                alter table bp3doc_store add 
                usearchiving
 integer null /* архивировать вместо удаления */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3doc_store' and 
           column_name   = 'nolog') then
                alter table bp3doc_store add 
                nolog
 integer null /* не записывать в журнал */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3doc_store' and 
           column_name   = 'shablonbrief') then
                alter table bp3doc_store add 
                shablonbrief
 varchar (100) null /* шаблон для краткого отображения */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3doc_store' and 
           column_name   = 'usechangelog') then
                alter table bp3doc_store add 
                usechangelog
 integer null /* вести журнал изменений */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3doc_store' and 
           column_name   = 'rulebrief') then
                alter table bp3doc_store add 
                rulebrief
 varchar (500) null /* правило составления brief поля */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'bp3doc_store' and 
           constraint_type   = 'primary key') then
            alter table bp3doc_store add constraint pk_bp3doc_store primary key (bp3doc_storeid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*поле*/
create table if not exists bp3doc_field/*поле*/ (
parentstructrowid binary(16) not null,
bp3doc_fieldid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3doc_field' and 
           column_name   = 'sequence') then
                alter table bp3doc_field add 
                sequence
 integer null /* № п/п */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3doc_field' and 
           column_name   = 'name') then
                alter table bp3doc_field add 
                name
 varchar (64) null /* имя поля */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3doc_field' and 
           column_name   = 'caption') then
                alter table bp3doc_field add 
                caption
 varchar (80) null /* надпись */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3doc_field' and 
           column_name   = 'tabname') then
                alter table bp3doc_field add 
                tabname
 varchar (60) null /* имя вкладки */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3doc_field' and 
           column_name   = 'fieldgroupbox') then
                alter table bp3doc_field add 
                fieldgroupbox
 varchar (60) null /* имя группы */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3doc_field' and 
           column_name   = 'allownull') then
                alter table bp3doc_field add 
                allownull
 integer null /* может быть пустым */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3doc_field' and 
           column_name   = 'fieldtype') then
                alter table bp3doc_field add 
                fieldtype binary(16) null /* тип поля */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3doc_field' and 
           column_name   = 'referencetype') then
                alter table bp3doc_field add 
                referencetype
 integer null /* тип ссылки */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3doc_field' and 
           column_name   = 'datasize') then
                alter table bp3doc_field add 
                datasize
 integer null /* размер поля */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3doc_field' and 
           column_name   = 'reftopart') then
                alter table bp3doc_field add 
                reftopart binary(16) null /* ссылка на раздел */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3doc_field' and 
           column_name   = 'internalreference') then
                alter table bp3doc_field add 
                internalreference
 integer null /* ссылка в пределах объекта */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3doc_field' and 
           column_name   = 'thecomment') then
                alter table bp3doc_field add 
                thecomment
 text null /* описание */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3doc_field' and 
           column_name   = 'isautonumber') then
                alter table bp3doc_field add 
                isautonumber
 integer null /* автонумерация */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3doc_field' and 
           column_name   = 'isbrief') then
                alter table bp3doc_field add 
                isbrief
 integer null /* краткая информация */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3doc_field' and 
           column_name   = 'istabbrief') then
                alter table bp3doc_field add 
                istabbrief
 integer null /* для отображения в таблице */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3doc_field' and 
           column_name   = 'thestyle') then
                alter table bp3doc_field add 
                thestyle
 varchar (50) null /* стиль */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3doc_field' and 
           column_name   = 'themask') then
                alter table bp3doc_field add 
                themask
 varchar (64) null /* маска */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3doc_field' and 
           column_name   = 'shablonbrief') then
                alter table bp3doc_field add 
                shablonbrief
 varchar (100) null /* шаблон для краткого отображения */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'bp3doc_field' and 
           constraint_type   = 'primary key') then
            alter table bp3doc_field add constraint pk_bp3doc_field primary key (bp3doc_fieldid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*описание*/
create table if not exists bp3doc_def/*описание документа*/ (
instanceid binary(16) ,
bp3doc_defid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3doc_def' and 
           column_name   = 'thecaption') then
                alter table bp3doc_def add 
                thecaption
 varchar (255) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3doc_def' and 
           column_name   = 'name') then
                alter table bp3doc_def add 
                name
 varchar (14) null /* код */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3doc_def' and 
           column_name   = 'issingleinstance') then
                alter table bp3doc_def add 
                issingleinstance
 integer null /* допускается только один объект */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3doc_def' and 
           column_name   = 'thecomment') then
                alter table bp3doc_def add 
                thecomment
 text null /* описание */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3doc_def' and 
           column_name   = 'useownership') then
                alter table bp3doc_def add 
                useownership
 integer null /* видмость зависит от пользователя */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3doc_def' and 
           column_name   = 'usearchiving') then
                alter table bp3doc_def add 
                usearchiving
 integer null /* архивировать вместо удаления */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3doc_def' and 
           column_name   = 'commitfullobject') then
                alter table bp3doc_def add 
                commitfullobject
 integer null /* сохранять объект целиком */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'bp3doc_def' and 
           constraint_type   = 'primary key') then
            alter table bp3doc_def add constraint pk_bp3doc_def primary key (bp3doc_defid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=bp3report (Отчет) */
GO

/*описание*/
create table if not exists bp3report_def/*описание*/ (
instanceid binary(16) ,
bp3report_defid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3report_def' and 
           column_name   = 'caption') then
                alter table bp3report_def add 
                caption
 varchar (255) null /* заголовок */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3report_def' and 
           column_name   = 'reporttype') then
                alter table bp3report_def add 
                reporttype
 integer null /* тип отчета */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3report_def' and 
           column_name   = 'thecomment') then
                alter table bp3report_def add 
                thecomment
 text null /* описание */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3report_def' and 
           column_name   = 'reportfile_ext') then
        alter table bp3report_def add 
            reportfile_ext nvarchar(4) null;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3report_def' and 
           column_name   = 'reportfile') then
                alter table bp3report_def add 
                reportfile
 mediumblob null /* файл отчета */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3report_def' and 
           column_name   = 'name') then
                alter table bp3report_def add 
                name
 varchar (255) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3report_def' and 
           column_name   = 'reportview') then
                alter table bp3report_def add 
                reportview binary(16) null /* базовый запрос */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'bp3report_def' and 
           constraint_type   = 'primary key') then
            alter table bp3report_def add constraint pk_bp3report_def primary key (bp3report_defid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*группа полей фильтра*/
create table if not exists bp3report_filter/*фильтр для отчета*/ (
instanceid binary(16) ,
bp3report_filterid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3report_filter' and 
           column_name   = 'name') then
                alter table bp3report_filter add 
                name
 varchar (64) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3report_filter' and 
           column_name   = 'sequence') then
                alter table bp3report_filter add 
                sequence
 integer null /* последовательность */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3report_filter' and 
           column_name   = 'allowignore') then
                alter table bp3report_filter add 
                allowignore
 integer null /* можно отключать */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3report_filter' and 
           column_name   = 'caption') then
                alter table bp3report_filter add 
                caption
 varchar (255) null /* заголовок */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'bp3report_filter' and 
           constraint_type   = 'primary key') then
            alter table bp3report_filter add constraint pk_bp3report_filter primary key (bp3report_filterid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*поле фильтра*/
create table if not exists bp3report_filterfiel/*поле фильтра*/ (
parentstructrowid binary(16) not null,
bp3report_filterfielid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3report_filterfiel' and 
           column_name   = 'reftopart') then
                alter table bp3report_filterfiel add 
                reftopart binary(16) null /* раздел, куда ссылаемся */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3report_filterfiel' and 
           column_name   = 'reftype') then
                alter table bp3report_filterfiel add 
                reftype
 integer null /* тип ссылки */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3report_filterfiel' and 
           column_name   = 'valuearray') then
                alter table bp3report_filterfiel add 
                valuearray
 integer null /* массив значений */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3report_filterfiel' and 
           column_name   = 'sequence') then
                alter table bp3report_filterfiel add 
                sequence
 integer null /* последовательность */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3report_filterfiel' and 
           column_name   = 'caption') then
                alter table bp3report_filterfiel add 
                caption
 varchar (255) null /* заголовок */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3report_filterfiel' and 
           column_name   = 'name') then
                alter table bp3report_filterfiel add 
                name
 varchar (255) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3report_filterfiel' and 
           column_name   = 'fieldtype') then
                alter table bp3report_filterfiel add 
                fieldtype binary(16) null /* тип поля */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'bp3report_filterfiel' and 
           column_name   = 'fieldsize') then
                alter table bp3report_filterfiel add 
                fieldsize
 integer null /* размер */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'bp3report_filterfiel' and 
           constraint_type   = 'primary key') then
            alter table bp3report_filterfiel add constraint pk_bp3report_filterfiel primary key (bp3report_filterfielid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--Index" BlockCode=" 


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'bp3ft_def' 
  and   index_name   = 'parent_bp3ft_def' ) then
   create index parent_bp3ft_def on bp3ft_def(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'bp3ft_map' 
  and   index_name   = 'parent_bp3ft_map' ) then
   create index parent_bp3ft_map on bp3ft_map(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'bp3ft_enums' 
  and   index_name   = 'parent_bp3ft_enums' ) then
   create index parent_bp3ft_enums on bp3ft_enums(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'bp3app_modules' 
  and   index_name   = 'parent_bp3app_modules' ) then
   create index parent_bp3app_modules on bp3app_modules(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'bp3app_oper' 
  and   index_name   = 'parent_bp3app_oper' ) then
create index parent_bp3app_oper on bp3app_oper(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'bp3app_menu' 
  and   index_name   = 'parent_bp3app_menu' ) then
   create index parent_bp3app_menu on bp3app_menu(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'bp3app_rigthtype' 
  and   index_name   = 'parent_bp3app_rigthtype' ) then
   create index parent_bp3app_rigthtype on bp3app_rigthtype(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'bp3app_info' 
  and   index_name   = 'parent_bp3app_info' ) then
   create index parent_bp3app_info on bp3app_info(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'bp3list_col' 
  and   index_name   = 'parent_bp3list_col' ) then
   create index parent_bp3list_col on bp3list_col(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'bp3list_colsrc' 
  and   index_name   = 'parent_bp3list_colsrc' ) then
create index parent_bp3list_colsrc on bp3list_colsrc(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'bp3list_def' 
  and   index_name   = 'parent_bp3list_def' ) then
   create index parent_bp3list_def on bp3list_def(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'bp3list_filter' 
  and   index_name   = 'parent_bp3list_filter' ) then
   create index parent_bp3list_filter on bp3list_filter(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'bp3list_filterfield' 
  and   index_name   = 'parent_bp3list_filterfield' ) then
create index parent_bp3list_filterfield on bp3list_filterfield(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'the_session' 
  and   index_name   = 'parent_the_session' ) then
   create index parent_the_session on the_session(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'sysrefcache' 
  and   index_name   = 'parent_sysrefcache' ) then
   create index parent_sysrefcache on sysrefcache(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'syslog' 
  and   index_name   = 'parent_syslog' ) then
   create index parent_syslog on syslog(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'bp3qry_column' 
  and   index_name   = 'parent_bp3qry_column' ) then
   create index parent_bp3qry_column on bp3qry_column(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'bp3qry_def' 
  and   index_name   = 'parent_bp3qry_def' ) then
   create index parent_bp3qry_def on bp3qry_def(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'bp3qry_link' 
  and   index_name   = 'parent_bp3qry_link' ) then
   create index parent_bp3qry_link on bp3qry_link(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'users' 
  and   index_name   = 'parent_users' ) then
   create index parent_users on users(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'groups' 
  and   index_name   = 'parent_groups' ) then
   create index parent_groups on groups(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'groupuser' 
  and   index_name   = 'parent_groupuser' ) then
create index parent_groupuser on groupuser(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'bp3dic_gen' 
  and   index_name   = 'parent_bp3dic_gen' ) then
   create index parent_bp3dic_gen on bp3dic_gen(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'bp3card_part' 
  and   index_name   = 'parent_bp3card_part' ) then
   create index parent_bp3card_part on bp3card_part(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'bp3card_fld' 
  and   index_name   = 'parent_bp3card_fld' ) then
   create index parent_bp3card_fld on bp3card_fld(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'bp3card_def' 
  and   index_name   = 'parent_bp3card_def' ) then
   create index parent_bp3card_def on bp3card_def(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'bp3doc_uk' 
  and   index_name   = 'parent_bp3doc_uk' ) then
   create index parent_bp3doc_uk on bp3doc_uk(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'bp3doc_ukfld' 
  and   index_name   = 'parent_bp3doc_ukfld' ) then
create index parent_bp3doc_ukfld on bp3doc_ukfld(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'bp3doc_store' 
  and   index_name   = 'parent_bp3doc_store' ) then
   create index parent_bp3doc_store on bp3doc_store(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'bp3doc_field' 
  and   index_name   = 'parent_bp3doc_field' ) then
create index parent_bp3doc_field on bp3doc_field(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'bp3doc_def' 
  and   index_name   = 'parent_bp3doc_def' ) then
   create index parent_bp3doc_def on bp3doc_def(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'bp3report_def' 
  and   index_name   = 'parent_bp3report_def' ) then
   create index parent_bp3report_def on bp3report_def(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'bp3report_filter' 
  and   index_name   = 'parent_bp3report_filter' ) then
   create index parent_bp3report_filter on bp3report_filter(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'bp3report_filterfiel' 
  and   index_name   = 'parent_bp3report_filterfiel' ) then
create index parent_bp3report_filterfiel on bp3report_filterfiel(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--ForeignKey" BlockCode="SET @@foreign_key_checks = 0;
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'bp3ft_def' and 
           constraint_type   = 'foreign key') then
alter table bp3ft_def add constraint fk_a9883f7bae1f4e2da144c8aa50869261 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'bp3ft_map' and 
           constraint_type   = 'foreign key') then
alter table bp3ft_map add constraint fk_124272bdb80642cebd5e471d49546dd8 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'bp3ft_enums' and 
           constraint_type   = 'foreign key') then
alter table bp3ft_enums add constraint fk_5ea529fa15814afea2a5783a717a4d60 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'bp3app_modules' and 
           constraint_type   = 'foreign key') then
alter table bp3app_modules add constraint fk_cc86c33864f046e8ad67df27f6950f1a foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'bp3app_oper' and 
           constraint_type   = 'foreign key') then
        alter table bp3app_oper add constraint fk_dd521afdfcc342bc93451b65e5ed1b27 foreign key(parentstructrowid) references bp3app_modules (bp3app_modulesid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'bp3app_menu' and 
           constraint_type   = 'foreign key') then
alter table bp3app_menu add constraint fk_9a878d618e804d4db5db893f01946752 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'bp3app_rigthtype' and 
           constraint_type   = 'foreign key') then
alter table bp3app_rigthtype add constraint fk_b067b562a3f9412ab85ec3fc25d3f04c foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'bp3app_info' and 
           constraint_type   = 'foreign key') then
alter table bp3app_info add constraint fk_678b4eb164b94c24b3c84fa674d7197f foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'bp3list_col' and 
           constraint_type   = 'foreign key') then
alter table bp3list_col add constraint fk_d039ec1c54134b029c0e250aba32a751 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'bp3list_colsrc' and 
           constraint_type   = 'foreign key') then
        alter table bp3list_colsrc add constraint fk_3057933d24bc496f98bcc4c14a0f1314 foreign key(parentstructrowid) references bp3list_col (bp3list_colid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'bp3list_def' and 
           constraint_type   = 'foreign key') then
alter table bp3list_def add constraint fk_fcc4b96110e14ca89dad8315da5363da foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'bp3list_filter' and 
           constraint_type   = 'foreign key') then
alter table bp3list_filter add constraint fk_187e86f3fc1c4f338f6b2a2184d11f81 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'bp3list_filterfield' and 
           constraint_type   = 'foreign key') then
        alter table bp3list_filterfield add constraint fk_12d59829fc064e66aa5748391c489327 foreign key(parentstructrowid) references bp3list_filter (bp3list_filterid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'the_session' and 
           constraint_type   = 'foreign key') then
alter table the_session add constraint fk_78943ea279364f58b31676e4f968e3b4 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'sysrefcache' and 
           constraint_type   = 'foreign key') then
alter table sysrefcache add constraint fk_35d224df283041549e80ff578aab323c foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'syslog' and 
           constraint_type   = 'foreign key') then
alter table syslog add constraint fk_45eadae898374ee59a3107370302f20f foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'bp3qry_column' and 
           constraint_type   = 'foreign key') then
alter table bp3qry_column add constraint fk_68d897760150400fabe748fa5890d6ce foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'bp3qry_def' and 
           constraint_type   = 'foreign key') then
alter table bp3qry_def add constraint fk_518b157ffad74651ab7b0d6b00b3b9ca foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'bp3qry_link' and 
           constraint_type   = 'foreign key') then
alter table bp3qry_link add constraint fk_47bc01f00b4b4e5398399376db5481c3 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'users' and 
           constraint_type   = 'foreign key') then
alter table users add constraint fk_148bb85509654e9ea3d648dcc8ce528b foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'groups' and 
           constraint_type   = 'foreign key') then
alter table groups add constraint fk_a40e6aee7b41476d923caca251c08e87 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'groupuser' and 
           constraint_type   = 'foreign key') then
        alter table groupuser add constraint fk_fe2c9352e29a420b91343e3bdd832a6e foreign key(parentstructrowid) references groups (groupsid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'bp3dic_gen' and 
           constraint_type   = 'foreign key') then
alter table bp3dic_gen add constraint fk_d0cba1d7885c49168482bea09abfa113 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'bp3card_part' and 
           constraint_type   = 'foreign key') then
alter table bp3card_part add constraint fk_02b66755f09f477aad246b65522fb971 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'bp3card_fld' and 
           constraint_type   = 'foreign key') then
alter table bp3card_fld add constraint fk_828a626e9e6b4fae815aad77ca604ca8 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'bp3card_def' and 
           constraint_type   = 'foreign key') then
alter table bp3card_def add constraint fk_0934acb00c984218a3c7982b93808554 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'bp3doc_uk' and 
           constraint_type   = 'foreign key') then
alter table bp3doc_uk add constraint fk_6dba8a13dcc844ada0d2d478725f9fb0 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'bp3doc_ukfld' and 
           constraint_type   = 'foreign key') then
        alter table bp3doc_ukfld add constraint fk_858d65b9f1384369b60fa69bfa7c6ad5 foreign key(parentstructrowid) references bp3doc_uk (bp3doc_ukid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'bp3doc_store' and 
           constraint_type   = 'foreign key') then
alter table bp3doc_store add constraint fk_abddd089d47547b4b04b8811c7ea0cf8 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'bp3doc_field' and 
           constraint_type   = 'foreign key') then
        alter table bp3doc_field add constraint fk_e01dfdd9604644dda2be8d760caef791 foreign key(parentstructrowid) references bp3doc_store (bp3doc_storeid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'bp3doc_def' and 
           constraint_type   = 'foreign key') then
alter table bp3doc_def add constraint fk_6f85a5d2fe9b4df3b237c39833b8e1e8 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'bp3report_def' and 
           constraint_type   = 'foreign key') then
alter table bp3report_def add constraint fk_9d66e4029f0349f1a2ebb99623ea6fd5 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'bp3report_filter' and 
           constraint_type   = 'foreign key') then
alter table bp3report_filter add constraint fk_8a1bad0ff6414d458be8f312d8b914b9 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'bp3report_filterfiel' and 
           constraint_type   = 'foreign key') then
        alter table bp3report_filterfiel add constraint fk_023a0560d85d4687a633782c9aff0a78 foreign key(parentstructrowid) references bp3report_filter (bp3report_filterid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO
SET @@foreign_key_checks = 1;
GO
">
      <FormData Name="" />
    </BlockHolder>
  </ModuleHolder>
  <ModuleHolder ModuleName="--FunctionsHeader" File="">
    <BlockHolder BlockName="--TableProc" BlockCode=" 


drop function IF EXISTS INSTANCE_MREF_F
GO

create function INSTANCE_MREF_F  (
 aINSTANCE_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  
DETERMINISTIC
 begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function if exists instance_brief_f
go
  create function instance_brief_f  (
 ainstanceid varchar(38)
 ,alang varchar(25)
)returns varchar(255) deterministic begin
 declare abrief varchar(255);
  set abrief=' to do';
  return abrief;
end
go


drop function IF EXISTS INSTANCE_MREF_F
GO

create function INSTANCE_MREF_F  (
 aINSTANCE_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  
DETERMINISTIC
 begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS bp3ft_def_BRIEF_F
GO

create function bp3ft_def_BRIEF_F  (
 abp3ft_defid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS bp3ft_def_MREF_F
GO
create function bp3ft_def_MREF_F  (
 abp3ft_def_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS bp3ft_map_BRIEF_F
GO

create function bp3ft_map_BRIEF_F  (
 abp3ft_mapid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS bp3ft_map_MREF_F
GO
create function bp3ft_map_MREF_F  (
 abp3ft_map_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS bp3ft_enums_BRIEF_F
GO

create function bp3ft_enums_BRIEF_F  (
 abp3ft_enumsid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS bp3ft_enums_MREF_F
GO
create function bp3ft_enums_MREF_F  (
 abp3ft_enums_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS BP3APP_MODULES_BRIEF_F
GO

create function BP3APP_MODULES_BRIEF_F  (
 aBP3APP_MODULESid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS BP3APP_MODULES_MREF_F
GO
create function BP3APP_MODULES_MREF_F  (
 aBP3APP_MODULES_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS BP3APP_OPER_BRIEF_F
GO

create function BP3APP_OPER_BRIEF_F  (
 aBP3APP_OPERid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS BP3APP_OPER_MREF_F
GO
create function BP3APP_OPER_MREF_F  (
 aBP3APP_OPER_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS BP3APP_MENU_BRIEF_F
GO

create function BP3APP_MENU_BRIEF_F  (
 aBP3APP_MENUid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS BP3APP_MENU_MREF_F
GO
create function BP3APP_MENU_MREF_F  (
 aBP3APP_MENU_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS BP3APP_RIGTHTYPE_BRIEF_F
GO

create function BP3APP_RIGTHTYPE_BRIEF_F  (
 aBP3APP_RIGTHTYPEid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS BP3APP_RIGTHTYPE_MREF_F
GO
create function BP3APP_RIGTHTYPE_MREF_F  (
 aBP3APP_RIGTHTYPE_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS BP3APP_INFO_BRIEF_F
GO

create function BP3APP_INFO_BRIEF_F  (
 aBP3APP_INFOid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS BP3APP_INFO_MREF_F
GO
create function BP3APP_INFO_MREF_F  (
 aBP3APP_INFO_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS bp3list_col_BRIEF_F
GO

create function bp3list_col_BRIEF_F  (
 abp3list_colid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS bp3list_col_MREF_F
GO
create function bp3list_col_MREF_F  (
 abp3list_col_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS bp3list_colsrc_BRIEF_F
GO

create function bp3list_colsrc_BRIEF_F  (
 abp3list_colsrcid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS bp3list_colsrc_MREF_F
GO
create function bp3list_colsrc_MREF_F  (
 abp3list_colsrc_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS bp3list_def_BRIEF_F
GO

create function bp3list_def_BRIEF_F  (
 abp3list_defid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS bp3list_def_MREF_F
GO
create function bp3list_def_MREF_F  (
 abp3list_def_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS bp3list_filter_BRIEF_F
GO

create function bp3list_filter_BRIEF_F  (
 abp3list_filterid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS bp3list_filter_MREF_F
GO
create function bp3list_filter_MREF_F  (
 abp3list_filter_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS bp3list_filterfield_BRIEF_F
GO

create function bp3list_filterfield_BRIEF_F  (
 abp3list_filterfieldid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS bp3list_filterfield_MREF_F
GO
create function bp3list_filterfield_MREF_F  (
 abp3list_filterfield_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS the_Session_BRIEF_F
GO

create function the_Session_BRIEF_F  (
 athe_Sessionid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS the_Session_MREF_F
GO
create function the_Session_MREF_F  (
 athe_Session_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS SysRefCache_BRIEF_F
GO

create function SysRefCache_BRIEF_F  (
 aSysRefCacheid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS SysRefCache_MREF_F
GO
create function SysRefCache_MREF_F  (
 aSysRefCache_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS SysLog_BRIEF_F
GO

create function SysLog_BRIEF_F  (
 aSysLogid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS SysLog_MREF_F
GO
create function SysLog_MREF_F  (
 aSysLog_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS bp3qry_column_BRIEF_F
GO

create function bp3qry_column_BRIEF_F  (
 abp3qry_columnid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS bp3qry_column_MREF_F
GO
create function bp3qry_column_MREF_F  (
 abp3qry_column_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS bp3qry_def_BRIEF_F
GO

create function bp3qry_def_BRIEF_F  (
 abp3qry_defid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS bp3qry_def_MREF_F
GO
create function bp3qry_def_MREF_F  (
 abp3qry_def_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS bp3qry_link_BRIEF_F
GO

create function bp3qry_link_BRIEF_F  (
 abp3qry_linkid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS bp3qry_link_MREF_F
GO
create function bp3qry_link_MREF_F  (
 abp3qry_link_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS Users_BRIEF_F
GO

create function Users_BRIEF_F  (
 aUsersid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS Users_MREF_F
GO
create function Users_MREF_F  (
 aUsers_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS Groups_BRIEF_F
GO

create function Groups_BRIEF_F  (
 aGroupsid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS Groups_MREF_F
GO
create function Groups_MREF_F  (
 aGroups_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS GroupUser_BRIEF_F
GO

create function GroupUser_BRIEF_F  (
 aGroupUserid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS GroupUser_MREF_F
GO
create function GroupUser_MREF_F  (
 aGroupUser_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS bp3dic_gen_BRIEF_F
GO

create function bp3dic_gen_BRIEF_F  (
 abp3dic_genid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS bp3dic_gen_MREF_F
GO
create function bp3dic_gen_MREF_F  (
 abp3dic_gen_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS bp3card_part_BRIEF_F
GO

create function bp3card_part_BRIEF_F  (
 abp3card_partid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS bp3card_part_MREF_F
GO
create function bp3card_part_MREF_F  (
 abp3card_part_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS bp3card_fld_BRIEF_F
GO

create function bp3card_fld_BRIEF_F  (
 abp3card_fldid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS bp3card_fld_MREF_F
GO
create function bp3card_fld_MREF_F  (
 abp3card_fld_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS bp3card_def_BRIEF_F
GO

create function bp3card_def_BRIEF_F  (
 abp3card_defid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS bp3card_def_MREF_F
GO
create function bp3card_def_MREF_F  (
 abp3card_def_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS bp3doc_uk_BRIEF_F
GO

create function bp3doc_uk_BRIEF_F  (
 abp3doc_ukid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS bp3doc_uk_MREF_F
GO
create function bp3doc_uk_MREF_F  (
 abp3doc_uk_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS bp3doc_ukfld_BRIEF_F
GO

create function bp3doc_ukfld_BRIEF_F  (
 abp3doc_ukfldid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS bp3doc_ukfld_MREF_F
GO
create function bp3doc_ukfld_MREF_F  (
 abp3doc_ukfld_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS bp3doc_store_BRIEF_F
GO

create function bp3doc_store_BRIEF_F  (
 abp3doc_storeid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS bp3doc_store_MREF_F
GO
create function bp3doc_store_MREF_F  (
 abp3doc_store_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS bp3doc_field_BRIEF_F
GO

create function bp3doc_field_BRIEF_F  (
 abp3doc_fieldid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS bp3doc_field_MREF_F
GO
create function bp3doc_field_MREF_F  (
 abp3doc_field_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS bp3doc_def_BRIEF_F
GO

create function bp3doc_def_BRIEF_F  (
 abp3doc_defid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS bp3doc_def_MREF_F
GO
create function bp3doc_def_MREF_F  (
 abp3doc_def_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS bp3report_def_BRIEF_F
GO

create function bp3report_def_BRIEF_F  (
 abp3report_defid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS bp3report_def_MREF_F
GO
create function bp3report_def_MREF_F  (
 abp3report_def_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS bp3report_filter_BRIEF_F
GO

create function bp3report_filter_BRIEF_F  (
 abp3report_filterid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS bp3report_filter_MREF_F
GO
create function bp3report_filter_MREF_F  (
 abp3report_filter_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS bp3report_filterfiel_BRIEF_F
GO

create function bp3report_filterfiel_BRIEF_F  (
 abp3report_filterfielid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS bp3report_filterfiel_MREF_F
GO
create function bp3report_filterfiel_MREF_F  (
 abp3report_filterfiel_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO
">
      <FormData Name="" />
    </BlockHolder>
  </ModuleHolder>
  <ModuleHolder ModuleName="--Functions" File="">
    <BlockHolder BlockName="--TableProc" BlockCode=" 


drop function if exists instance_mref_f
go
create function instance_mref_f  (
 ainstance_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select instance_brief_f(instanceid, alang)  from instance
where ainstance_ref like concat('%',replace(replace(b2g(instanceid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO


drop function if exists instance_brief_f
go
  create function instance_brief_f  (
 ainstanceid binary(16)
 ,alang varchar(25)
)returns varchar(255)
reads sql data
begin
 declare abrief varchar(255);
 declare aec int;
if ainstanceid is null then set abrief=''; return abrief; end if;
select count(*) into aec from instance where instanceid=ainstanceid;
if aec=0 then
  set abrief='';
  select concat(abrief
  ,  ifnull(name,''))
 into abrief from instance  where  instanceid = ainstanceid;
else
  set abrief= '';
end if;
set abrief=left(abrief,255);
  return abrief;
end
go
GO


drop function if exists instance_mref_f
go
create function instance_mref_f  (
 ainstance_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select instance_brief_f(instanceid, alang)  from instance
where ainstance_ref like concat('%',replace(replace(b2g(instanceid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists bp3ft_def_brief_f
go

create function bp3ft_def_brief_f  (
 abp3ft_defid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if abp3ft_defid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from bp3ft_def where bp3ft_defid=abp3ft_defid;
if aec&lt;&gt;0 then
  set abrief='';
 select typestyle
 into aec  from bp3ft_def where bp3ft_defid=abp3ft_defid;
  case aec 
when 4 then 
  select concat(abrief ,
 'ссылка; ') into abrief ;
when 1 then 
  select concat(abrief ,
 'выражение; ') into abrief ;
when 5 then 
  select concat(abrief ,
 'элемент оформления; ') into abrief ;
when 3 then 
  select concat(abrief ,
 'интервал; ') into abrief ;
when 2 then 
  select concat(abrief ,
 'перечисление; ') into abrief ;
when 0 then 
  select concat(abrief ,
 'скалярный тип; ') into abrief ;
 else 
  select concat(abrief ,
 '; ') into abrief ;
  end case; 
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from bp3ft_def  where  bp3ft_defid = abp3ft_defid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists bp3ft_def_mref_f
go

create function bp3ft_def_mref_f  (
 abp3ft_def_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select bp3ft_def_brief_f(bp3ft_defid, alang)  from bp3ft_def
where abp3ft_def_ref like concat('%',replace(replace(b2g(bp3ft_defid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists bp3ft_map_brief_f
go

create function bp3ft_map_brief_f  (
 abp3ft_mapid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if abp3ft_mapid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from bp3ft_map where bp3ft_mapid=abp3ft_mapid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(stoagetype,'') ,' '  )
  into abrief   from bp3ft_map  where  bp3ft_mapid = abp3ft_mapid; 
select target
 into atmpid  from bp3ft_map  where  bp3ft_mapid = abp3ft_mapid; 
 select bp3dic_gen_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists bp3ft_map_mref_f
go

create function bp3ft_map_mref_f  (
 abp3ft_map_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select bp3ft_map_brief_f(bp3ft_mapid, alang)  from bp3ft_map
where abp3ft_map_ref like concat('%',replace(replace(b2g(bp3ft_mapid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists bp3ft_enums_brief_f
go

create function bp3ft_enums_brief_f  (
 abp3ft_enumsid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if abp3ft_enumsid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from bp3ft_enums where bp3ft_enumsid=abp3ft_enumsid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from bp3ft_enums  where  bp3ft_enumsid = abp3ft_enumsid; 
  select concat(abrief 
  , '' , ifnull(namevalue,'') ,' '  )
  into abrief   from bp3ft_enums  where  bp3ft_enumsid = abp3ft_enumsid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists bp3ft_enums_mref_f
go

create function bp3ft_enums_mref_f  (
 abp3ft_enums_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select bp3ft_enums_brief_f(bp3ft_enumsid, alang)  from bp3ft_enums
where abp3ft_enums_ref like concat('%',replace(replace(b2g(bp3ft_enumsid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists bp3app_modules_brief_f
go

create function bp3app_modules_brief_f  (
 abp3app_modulesid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if abp3app_modulesid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from bp3app_modules where bp3app_modulesid=abp3app_modulesid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(caption,'') ,' '  )
  into abrief   from bp3app_modules  where  bp3app_modulesid = abp3app_modulesid; 
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from bp3app_modules  where  bp3app_modulesid = abp3app_modulesid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists bp3app_modules_mref_f
go

create function bp3app_modules_mref_f  (
 abp3app_modules_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select bp3app_modules_brief_f(bp3app_modulesid, alang)  from bp3app_modules
where abp3app_modules_ref like concat('%',replace(replace(b2g(bp3app_modulesid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists bp3app_oper_brief_f
go

create function bp3app_oper_brief_f  (
 abp3app_operid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if abp3app_operid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from bp3app_oper where bp3app_operid=abp3app_operid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(caption,'') ,' '  )
  into abrief   from bp3app_oper  where  bp3app_operid = abp3app_operid; 
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from bp3app_oper  where  bp3app_operid = abp3app_operid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists bp3app_oper_mref_f
go

create function bp3app_oper_mref_f  (
 abp3app_oper_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select bp3app_oper_brief_f(bp3app_operid, alang)  from bp3app_oper
where abp3app_oper_ref like concat('%',replace(replace(b2g(bp3app_operid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists bp3app_menu_brief_f
go

create function bp3app_menu_brief_f  (
 abp3app_menuid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if abp3app_menuid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from bp3app_menu where bp3app_menuid=abp3app_menuid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(caption,'') ,' '  )
  into abrief   from bp3app_menu  where  bp3app_menuid = abp3app_menuid; 
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from bp3app_menu  where  bp3app_menuid = abp3app_menuid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists bp3app_menu_mref_f
go

create function bp3app_menu_mref_f  (
 abp3app_menu_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select bp3app_menu_brief_f(bp3app_menuid, alang)  from bp3app_menu
where abp3app_menu_ref like concat('%',replace(replace(b2g(bp3app_menuid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists bp3app_rigthtype_brief_f
go

create function bp3app_rigthtype_brief_f  (
 abp3app_rigthtypeid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if abp3app_rigthtypeid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from bp3app_rigthtype where bp3app_rigthtypeid=abp3app_rigthtypeid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from bp3app_rigthtype  where  bp3app_rigthtypeid = abp3app_rigthtypeid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists bp3app_rigthtype_mref_f
go

create function bp3app_rigthtype_mref_f  (
 abp3app_rigthtype_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select bp3app_rigthtype_brief_f(bp3app_rigthtypeid, alang)  from bp3app_rigthtype
where abp3app_rigthtype_ref like concat('%',replace(replace(b2g(bp3app_rigthtypeid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists bp3app_info_brief_f
go

create function bp3app_info_brief_f  (
 abp3app_infoid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if abp3app_infoid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from bp3app_info where bp3app_infoid=abp3app_infoid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from bp3app_info  where  bp3app_infoid = abp3app_infoid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists bp3app_info_mref_f
go

create function bp3app_info_mref_f  (
 abp3app_info_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select bp3app_info_brief_f(bp3app_infoid, alang)  from bp3app_info
where abp3app_info_ref like concat('%',replace(replace(b2g(bp3app_infoid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists bp3list_col_brief_f
go

create function bp3list_col_brief_f  (
 abp3list_colid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if abp3list_colid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from bp3list_col where bp3list_colid=abp3list_colid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from bp3list_col  where  bp3list_colid = abp3list_colid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists bp3list_col_mref_f
go

create function bp3list_col_mref_f  (
 abp3list_col_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select bp3list_col_brief_f(bp3list_colid, alang)  from bp3list_col
where abp3list_col_ref like concat('%',replace(replace(b2g(bp3list_colid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists bp3list_colsrc_brief_f
go

create function bp3list_colsrc_brief_f  (
 abp3list_colsrcid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if abp3list_colsrcid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from bp3list_colsrc where bp3list_colsrcid=abp3list_colsrcid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(viewfield,'') ,' '  )
  into abrief   from bp3list_colsrc  where  bp3list_colsrcid = abp3list_colsrcid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists bp3list_colsrc_mref_f
go

create function bp3list_colsrc_mref_f  (
 abp3list_colsrc_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select bp3list_colsrc_brief_f(bp3list_colsrcid, alang)  from bp3list_colsrc
where abp3list_colsrc_ref like concat('%',replace(replace(b2g(bp3list_colsrcid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists bp3list_def_brief_f
go

create function bp3list_def_brief_f  (
 abp3list_defid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if abp3list_defid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from bp3list_def where bp3list_defid=abp3list_defid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from bp3list_def  where  bp3list_defid = abp3list_defid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists bp3list_def_mref_f
go

create function bp3list_def_mref_f  (
 abp3list_def_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select bp3list_def_brief_f(bp3list_defid, alang)  from bp3list_def
where abp3list_def_ref like concat('%',replace(replace(b2g(bp3list_defid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists bp3list_filter_brief_f
go

create function bp3list_filter_brief_f  (
 abp3list_filterid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if abp3list_filterid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from bp3list_filter where bp3list_filterid=abp3list_filterid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(caption,'') ,' '  )
  into abrief   from bp3list_filter  where  bp3list_filterid = abp3list_filterid; 
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from bp3list_filter  where  bp3list_filterid = abp3list_filterid; 
 select allowignore
 into aec  from bp3list_filter where bp3list_filterid=abp3list_filterid;
  case aec 
when -1 then 
  select concat(abrief ,
 'да; ') into abrief ;
when 0 then 
  select concat(abrief ,
 'нет; ') into abrief ;
 else 
  select concat(abrief ,
 '; ') into abrief ;
  end case; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists bp3list_filter_mref_f
go

create function bp3list_filter_mref_f  (
 abp3list_filter_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select bp3list_filter_brief_f(bp3list_filterid, alang)  from bp3list_filter
where abp3list_filter_ref like concat('%',replace(replace(b2g(bp3list_filterid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists bp3list_filterfield_brief_f
go

create function bp3list_filterfield_brief_f  (
 abp3list_filterfieldid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if abp3list_filterfieldid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from bp3list_filterfield where bp3list_filterfieldid=abp3list_filterfieldid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(caption,'') ,' '  )
  into abrief   from bp3list_filterfield  where  bp3list_filterfieldid = abp3list_filterfieldid; 
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from bp3list_filterfield  where  bp3list_filterfieldid = abp3list_filterfieldid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists bp3list_filterfield_mref_f
go

create function bp3list_filterfield_mref_f  (
 abp3list_filterfield_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select bp3list_filterfield_brief_f(bp3list_filterfieldid, alang)  from bp3list_filterfield
where abp3list_filterfield_ref like concat('%',replace(replace(b2g(bp3list_filterfieldid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists the_session_brief_f
go

create function the_session_brief_f  (
 athe_sessionid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if athe_sessionid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from the_session where the_sessionid=athe_sessionid;
if aec&lt;&gt;0 then
  set abrief='';
select userrole
 into atmpid  from the_session  where  the_sessionid = athe_sessionid; 
 select groups_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
 select closed
 into aec  from the_session where the_sessionid=athe_sessionid;
  case aec 
when 1 then 
  select concat(abrief ,
 'да; ') into abrief ;
when 0 then 
  select concat(abrief ,
 'нет; ') into abrief ;
 else 
  select concat(abrief ,
 '; ') into abrief ;
  end case; 
select usersid
 into atmpid  from the_session  where  the_sessionid = athe_sessionid; 
 select users_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists the_session_mref_f
go

create function the_session_mref_f  (
 athe_session_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select the_session_brief_f(the_sessionid, alang)  from the_session
where athe_session_ref like concat('%',replace(replace(b2g(the_sessionid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists sysrefcache_brief_f
go

create function sysrefcache_brief_f  (
 asysrefcacheid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if asysrefcacheid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from sysrefcache where sysrefcacheid=asysrefcacheid;
if aec&lt;&gt;0 then
  set abrief='';
select sessionid
 into atmpid  from sysrefcache  where  sysrefcacheid = asysrefcacheid; 
 select the_session_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists sysrefcache_mref_f
go

create function sysrefcache_mref_f  (
 asysrefcache_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select sysrefcache_brief_f(sysrefcacheid, alang)  from sysrefcache
where asysrefcache_ref like concat('%',replace(replace(b2g(sysrefcacheid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists syslog_brief_f
go

create function syslog_brief_f  (
 asyslogid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if asyslogid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from syslog where syslogid=asyslogid;
if aec&lt;&gt;0 then
  set abrief='';
select thesession
 into atmpid  from syslog  where  syslogid = asyslogid; 
 select the_session_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
  select concat(abrief 
  , '' , ifnull(logstructid,'') ,' '  )
  into abrief   from syslog  where  syslogid = asyslogid; 
  select concat(abrief 
  , '' , ifnull(verb,'') ,' '  )
  into abrief   from syslog  where  syslogid = asyslogid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists syslog_mref_f
go

create function syslog_mref_f  (
 asyslog_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select syslog_brief_f(syslogid, alang)  from syslog
where asyslog_ref like concat('%',replace(replace(b2g(syslogid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists bp3qry_column_brief_f
go

create function bp3qry_column_brief_f  (
 abp3qry_columnid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if abp3qry_columnid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from bp3qry_column where bp3qry_columnid=abp3qry_columnid;
if aec&lt;&gt;0 then
  set abrief='';
select frompart
 into atmpid  from bp3qry_column  where  bp3qry_columnid = abp3qry_columnid; 
 select bp3doc_store_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
 select aggregation
 into aec  from bp3qry_column where bp3qry_columnid=abp3qry_columnid;
  case aec 
when 3 then 
  select concat(abrief ,
 'sum; ') into abrief ;
when 1 then 
  select concat(abrief ,
 'avg; ') into abrief ;
when 6 then 
  select concat(abrief ,
 'custom; ') into abrief ;
when 0 then 
  select concat(abrief ,
 'none; ') into abrief ;
when 2 then 
  select concat(abrief ,
 'count; ') into abrief ;
when 5 then 
  select concat(abrief ,
 'max; ') into abrief ;
when 4 then 
  select concat(abrief ,
 'min; ') into abrief ;
 else 
  select concat(abrief ,
 '; ') into abrief ;
  end case; 
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from bp3qry_column  where  bp3qry_columnid = abp3qry_columnid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists bp3qry_column_mref_f
go

create function bp3qry_column_mref_f  (
 abp3qry_column_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select bp3qry_column_brief_f(bp3qry_columnid, alang)  from bp3qry_column
where abp3qry_column_ref like concat('%',replace(replace(b2g(bp3qry_columnid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists bp3qry_def_brief_f
go

create function bp3qry_def_brief_f  (
 abp3qry_defid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if abp3qry_defid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from bp3qry_def where bp3qry_defid=abp3qry_defid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from bp3qry_def  where  bp3qry_defid = abp3qry_defid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists bp3qry_def_mref_f
go

create function bp3qry_def_mref_f  (
 abp3qry_def_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select bp3qry_def_brief_f(bp3qry_defid, alang)  from bp3qry_def
where abp3qry_def_ref like concat('%',replace(replace(b2g(bp3qry_defid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists bp3qry_link_brief_f
go

create function bp3qry_link_brief_f  (
 abp3qry_linkid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if abp3qry_linkid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from bp3qry_link where bp3qry_linkid=abp3qry_linkid;
if aec&lt;&gt;0 then
  set abrief='';
select theview
 into atmpid  from bp3qry_link  where  bp3qry_linkid = abp3qry_linkid; 
 select bp3qry_def_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists bp3qry_link_mref_f
go

create function bp3qry_link_mref_f  (
 abp3qry_link_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select bp3qry_link_brief_f(bp3qry_linkid, alang)  from bp3qry_link
where abp3qry_link_ref like concat('%',replace(replace(b2g(bp3qry_linkid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists users_brief_f
go

create function users_brief_f  (
 ausersid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if ausersid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from users where usersid=ausersid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(family,'') ,' '  )
  into abrief   from users  where  usersid = ausersid; 
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from users  where  usersid = ausersid; 
  select concat(abrief 
  , '' , ifnull(surname,'') ,' '  )
  into abrief   from users  where  usersid = ausersid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists users_mref_f
go

create function users_mref_f  (
 ausers_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select users_brief_f(usersid, alang)  from users
where ausers_ref like concat('%',replace(replace(b2g(usersid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists groups_brief_f
go

create function groups_brief_f  (
 agroupsid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if agroupsid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from groups where groupsid=agroupsid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from groups  where  groupsid = agroupsid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists groups_mref_f
go

create function groups_mref_f  (
 agroups_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select groups_brief_f(groupsid, alang)  from groups
where agroups_ref like concat('%',replace(replace(b2g(groupsid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists groupuser_brief_f
go

create function groupuser_brief_f  (
 agroupuserid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if agroupuserid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from groupuser where groupuserid=agroupuserid;
if aec&lt;&gt;0 then
  set abrief='';
select theuser
 into atmpid  from groupuser  where  groupuserid = agroupuserid; 
 select users_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists groupuser_mref_f
go

create function groupuser_mref_f  (
 agroupuser_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select groupuser_brief_f(groupuserid, alang)  from groupuser
where agroupuser_ref like concat('%',replace(replace(b2g(groupuserid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists bp3dic_gen_brief_f
go

create function bp3dic_gen_brief_f  (
 abp3dic_genid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if abp3dic_genid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from bp3dic_gen where bp3dic_genid=abp3dic_genid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from bp3dic_gen  where  bp3dic_genid = abp3dic_genid; 
 select targettype
 into aec  from bp3dic_gen where bp3dic_genid=abp3dic_genid;
  case aec 
when 0 then 
  select concat(abrief ,
 'субд; ') into abrief ;
when 3 then 
  select concat(abrief ,
 'документация; ') into abrief ;
when 1 then 
  select concat(abrief ,
 'модель; ') into abrief ;
when 2 then 
  select concat(abrief ,
 'приложение; ') into abrief ;
when 4 then 
  select concat(abrief ,
 'арм; ') into abrief ;
 else 
  select concat(abrief ,
 '; ') into abrief ;
  end case; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists bp3dic_gen_mref_f
go

create function bp3dic_gen_mref_f  (
 abp3dic_gen_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select bp3dic_gen_brief_f(bp3dic_genid, alang)  from bp3dic_gen
where abp3dic_gen_ref like concat('%',replace(replace(b2g(bp3dic_genid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists bp3card_part_brief_f
go

create function bp3card_part_brief_f  (
 abp3card_partid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if abp3card_partid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from bp3card_part where bp3card_partid=abp3card_partid;
if aec&lt;&gt;0 then
  set abrief='';
 select allowadd
 into aec  from bp3card_part where bp3card_partid=abp3card_partid;
  case aec 
when -1 then 
  select concat(abrief ,
 'да; ') into abrief ;
when 0 then 
  select concat(abrief ,
 'нет; ') into abrief ;
 else 
  select concat(abrief ,
 '; ') into abrief ;
  end case; 
 select allowdelete
 into aec  from bp3card_part where bp3card_partid=abp3card_partid;
  case aec 
when -1 then 
  select concat(abrief ,
 'да; ') into abrief ;
when 0 then 
  select concat(abrief ,
 'нет; ') into abrief ;
 else 
  select concat(abrief ,
 '; ') into abrief ;
  end case; 
 select allowread
 into aec  from bp3card_part where bp3card_partid=abp3card_partid;
  case aec 
when -1 then 
  select concat(abrief ,
 'да; ') into abrief ;
when 0 then 
  select concat(abrief ,
 'нет; ') into abrief ;
 else 
  select concat(abrief ,
 '; ') into abrief ;
  end case; 
select struct
 into atmpid  from bp3card_part  where  bp3card_partid = abp3card_partid; 
 select bp3card_part_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
 select allowedit
 into aec  from bp3card_part where bp3card_partid=abp3card_partid;
  case aec 
when -1 then 
  select concat(abrief ,
 'да; ') into abrief ;
when 0 then 
  select concat(abrief ,
 'нет; ') into abrief ;
 else 
  select concat(abrief ,
 '; ') into abrief ;
  end case; 
  select concat(abrief 
  , '' , ifnull(caption,'') ,' '  )
  into abrief   from bp3card_part  where  bp3card_partid = abp3card_partid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists bp3card_part_mref_f
go

create function bp3card_part_mref_f  (
 abp3card_part_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select bp3card_part_brief_f(bp3card_partid, alang)  from bp3card_part
where abp3card_part_ref like concat('%',replace(replace(b2g(bp3card_partid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists bp3card_fld_brief_f
go

create function bp3card_fld_brief_f  (
 abp3card_fldid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if abp3card_fldid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from bp3card_fld where bp3card_fldid=abp3card_fldid;
if aec&lt;&gt;0 then
  set abrief='';
select thefield
 into atmpid  from bp3card_fld  where  bp3card_fldid = abp3card_fldid; 
 select bp3card_fld_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
select thepart
 into atmpid  from bp3card_fld  where  bp3card_fldid = abp3card_fldid; 
 select bp3card_part_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
 select allowmodify
 into aec  from bp3card_fld where bp3card_fldid=abp3card_fldid;
  case aec 
when -1 then 
  select concat(abrief ,
 'да; ') into abrief ;
when 0 then 
  select concat(abrief ,
 'нет; ') into abrief ;
 else 
  select concat(abrief ,
 '; ') into abrief ;
  end case; 
 select allowread
 into aec  from bp3card_fld where bp3card_fldid=abp3card_fldid;
  case aec 
when -1 then 
  select concat(abrief ,
 'да; ') into abrief ;
when 0 then 
  select concat(abrief ,
 'нет; ') into abrief ;
 else 
  select concat(abrief ,
 '; ') into abrief ;
  end case; 
  select concat(abrief 
  , '' , ifnull(caption,'') ,' '  )
  into abrief   from bp3card_fld  where  bp3card_fldid = abp3card_fldid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists bp3card_fld_mref_f
go

create function bp3card_fld_mref_f  (
 abp3card_fld_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select bp3card_fld_brief_f(bp3card_fldid, alang)  from bp3card_fld
where abp3card_fld_ref like concat('%',replace(replace(b2g(bp3card_fldid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists bp3card_def_brief_f
go

create function bp3card_def_brief_f  (
 abp3card_defid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if abp3card_defid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from bp3card_def where bp3card_defid=abp3card_defid;
if aec&lt;&gt;0 then
  set abrief='';
select cardfor
 into atmpid  from bp3card_def  where  bp3card_defid = abp3card_defid; 
 select bp3doc_def_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from bp3card_def  where  bp3card_defid = abp3card_defid; 
 select defaultmode
 into aec  from bp3card_def where bp3card_defid=abp3card_defid;
  case aec 
when -1 then 
  select concat(abrief ,
 'да; ') into abrief ;
when 0 then 
  select concat(abrief ,
 'нет; ') into abrief ;
 else 
  select concat(abrief ,
 '; ') into abrief ;
  end case; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists bp3card_def_mref_f
go

create function bp3card_def_mref_f  (
 abp3card_def_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select bp3card_def_brief_f(bp3card_defid, alang)  from bp3card_def
where abp3card_def_ref like concat('%',replace(replace(b2g(bp3card_defid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists bp3doc_uk_brief_f
go

create function bp3doc_uk_brief_f  (
 abp3doc_ukid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if abp3doc_ukid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from bp3doc_uk where bp3doc_ukid=abp3doc_ukid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from bp3doc_uk  where  bp3doc_ukid = abp3doc_ukid; 
 select perparent
 into aec  from bp3doc_uk where bp3doc_ukid=abp3doc_ukid;
  case aec 
when -1 then 
  select concat(abrief ,
 'да; ') into abrief ;
when 0 then 
  select concat(abrief ,
 'нет; ') into abrief ;
 else 
  select concat(abrief ,
 '; ') into abrief ;
  end case; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists bp3doc_uk_mref_f
go

create function bp3doc_uk_mref_f  (
 abp3doc_uk_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select bp3doc_uk_brief_f(bp3doc_ukid, alang)  from bp3doc_uk
where abp3doc_uk_ref like concat('%',replace(replace(b2g(bp3doc_ukid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists bp3doc_ukfld_brief_f
go

create function bp3doc_ukfld_brief_f  (
 abp3doc_ukfldid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if abp3doc_ukfldid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from bp3doc_ukfld where bp3doc_ukfldid=abp3doc_ukfldid;
if aec&lt;&gt;0 then
  set abrief='';
select thefield
 into atmpid  from bp3doc_ukfld  where  bp3doc_ukfldid = abp3doc_ukfldid; 
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists bp3doc_ukfld_mref_f
go

create function bp3doc_ukfld_mref_f  (
 abp3doc_ukfld_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select bp3doc_ukfld_brief_f(bp3doc_ukfldid, alang)  from bp3doc_ukfld
where abp3doc_ukfld_ref like concat('%',replace(replace(b2g(bp3doc_ukfldid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists bp3doc_store_brief_f
go

create function bp3doc_store_brief_f  (
 abp3doc_storeid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if abp3doc_storeid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from bp3doc_store where bp3doc_storeid=abp3doc_storeid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(caption,'') ,' '  )
  into abrief   from bp3doc_store  where  bp3doc_storeid = abp3doc_storeid; 
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from bp3doc_store  where  bp3doc_storeid = abp3doc_storeid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists bp3doc_store_mref_f
go

create function bp3doc_store_mref_f  (
 abp3doc_store_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select bp3doc_store_brief_f(bp3doc_storeid, alang)  from bp3doc_store
where abp3doc_store_ref like concat('%',replace(replace(b2g(bp3doc_storeid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists bp3doc_field_brief_f
go

create function bp3doc_field_brief_f  (
 abp3doc_fieldid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if abp3doc_fieldid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from bp3doc_field where bp3doc_fieldid=abp3doc_fieldid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from bp3doc_field  where  bp3doc_fieldid = abp3doc_fieldid; 
  select concat(abrief 
  , '' , ifnull(caption,'') ,' '  )
  into abrief   from bp3doc_field  where  bp3doc_fieldid = abp3doc_fieldid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists bp3doc_field_mref_f
go

create function bp3doc_field_mref_f  (
 abp3doc_field_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select bp3doc_field_brief_f(bp3doc_fieldid, alang)  from bp3doc_field
where abp3doc_field_ref like concat('%',replace(replace(b2g(bp3doc_fieldid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists bp3doc_def_brief_f
go

create function bp3doc_def_brief_f  (
 abp3doc_defid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if abp3doc_defid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from bp3doc_def where bp3doc_defid=abp3doc_defid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(thecaption,'') ,' '  )
  into abrief   from bp3doc_def  where  bp3doc_defid = abp3doc_defid; 
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from bp3doc_def  where  bp3doc_defid = abp3doc_defid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists bp3doc_def_mref_f
go

create function bp3doc_def_mref_f  (
 abp3doc_def_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select bp3doc_def_brief_f(bp3doc_defid, alang)  from bp3doc_def
where abp3doc_def_ref like concat('%',replace(replace(b2g(bp3doc_defid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists bp3report_def_brief_f
go

create function bp3report_def_brief_f  (
 abp3report_defid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if abp3report_defid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from bp3report_def where bp3report_defid=abp3report_defid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from bp3report_def  where  bp3report_defid = abp3report_defid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists bp3report_def_mref_f
go

create function bp3report_def_mref_f  (
 abp3report_def_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select bp3report_def_brief_f(bp3report_defid, alang)  from bp3report_def
where abp3report_def_ref like concat('%',replace(replace(b2g(bp3report_defid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists bp3report_filter_brief_f
go

create function bp3report_filter_brief_f  (
 abp3report_filterid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if abp3report_filterid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from bp3report_filter where bp3report_filterid=abp3report_filterid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from bp3report_filter  where  bp3report_filterid = abp3report_filterid; 
 select allowignore
 into aec  from bp3report_filter where bp3report_filterid=abp3report_filterid;
  case aec 
when -1 then 
  select concat(abrief ,
 'да; ') into abrief ;
when 0 then 
  select concat(abrief ,
 'нет; ') into abrief ;
 else 
  select concat(abrief ,
 '; ') into abrief ;
  end case; 
  select concat(abrief 
  , '' , ifnull(caption,'') ,' '  )
  into abrief   from bp3report_filter  where  bp3report_filterid = abp3report_filterid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists bp3report_filter_mref_f
go

create function bp3report_filter_mref_f  (
 abp3report_filter_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select bp3report_filter_brief_f(bp3report_filterid, alang)  from bp3report_filter
where abp3report_filter_ref like concat('%',replace(replace(b2g(bp3report_filterid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists bp3report_filterfiel_brief_f
go

create function bp3report_filterfiel_brief_f  (
 abp3report_filterfielid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if abp3report_filterfielid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from bp3report_filterfiel where bp3report_filterfielid=abp3report_filterfielid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(caption,'') ,' '  )
  into abrief   from bp3report_filterfiel  where  bp3report_filterfielid = abp3report_filterfielid; 
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from bp3report_filterfiel  where  bp3report_filterfielid = abp3report_filterfielid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists bp3report_filterfiel_mref_f
go

create function bp3report_filterfiel_mref_f  (
 abp3report_filterfiel_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select bp3report_filterfiel_brief_f(bp3report_filterfielid, alang)  from bp3report_filterfiel
where abp3report_filterfiel_ref like concat('%',replace(replace(b2g(bp3report_filterfielid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO
">
      <FormData Name="" />
    </BlockHolder>
  </ModuleHolder>
  <ModuleHolder ModuleName="--Kernel procs" File="">
    <BlockHolder BlockName="--body" BlockCode=" 


drop function if exists b2g
go
        create  function `b2g`(
    $data binary(16)
) returns char(38) 
    deterministic
begin
    declare $result char(38) default null;
    if $data is not null then
        set $result = concat('{',hex(substring($data,4,1)),hex(substring($data,3,1)),hex(substring($data,2,1)), hex(substring($data,1,1)) , '-', 
                hex(substring($data,6,1)),hex(substring($data,5,1)),'-',
                hex(substring($data,8,1)) , hex(substring($data,7,1)),'-',
                hex(substring($data,9,2)),'-',hex(substring($data,11,6)) ,'}');
        set $result = ucase($result);
    end if;
    return $result;
end
go

drop function if exists g2b
go
create  function `g2b`(
    $data varchar(38)
) returns binary(16)
    deterministic
begin
    declare $result binary(16) default null;
    if $data is not null then
        set $data = replace($data,'-','');
        set $data = replace($data,'{','');
        set $data = replace($data,'}','');
        set $result = concat(unhex(substring($data,7,2)),unhex(substring($data,5,2)),unhex(substring($data,3,2)), unhex(substring($data,1,2)),
                unhex(substring($data,11,2)),unhex(substring($data,9,2)),unhex(substring($data,15,2)) , unhex(substring($data,13,2)),
                unhex(substring($data,17,16)));
    end if;
    return $result;
end
go

drop function if exists checkoperation
go
create  function `checkoperation`(
    acursession varchar(38)
    ,aopname varchar(255)
) returns tinyint(1)
    reads sql data
begin
  declare isok int;
  select 1 into isok;
 /* select roles_operations.allowaction into isok from   roles_operations  
      join roles_def on roles_def.instanceid=roles_operations.instanceid
      join the_session on the_session.userrole=roles_def.roles_defid
      where the_session.the_sessionid=g2b(acursession) 
      and roles_operations.name=aopname; */
  if isok&lt;&gt;0 then
      return 1;
  else
      return 0;
  end if;
end
go

drop procedure if exists login
go
create  procedure `login`(
 out athe_session varchar(38)/* идентификатор новой сессии */
,apwd varchar(80)/* пароль */
,ausr varchar (64)/* имя пользователя */
)
body:   begin
    declare aid binary(16); 
    declare ausersid binary(16); 
    declare asysid binary(16); 
    declare existscnt int;  
    declare astatus varchar(38);
set asysid = null; 
select instanceid into asysid from instance where objtype = 'mtzsystem'; 
set athe_session=null  ; 
set ausersid=null;
 if apwd is null then 
    set athe_session=null  ; 
 else 
	 select usersid into ausersid from users where login=ausr and password =md5(apwd); 
	 set  aid=g2b(uuid())  ; 
	 if not ausersid  is null then
		 if asysid is null then 
				insert into the_session(the_sessionid,lastaccess,usersid,closed,startat,changestamp)
				values(aid,sysdate,ausersid,0,now(),now()); 
		else 
				insert into the_session(instanceid,the_sessionid,lastaccess,usersid,closed,startat,changestamp)
				values(asysid,aid,now(),ausersid,0,now(),now()); 
		end if; 
		set athe_session=b2g(aid); 
	 end if;
	-- call build_usercache(b2g(aid));
 end if;
end
go

drop procedure if exists logout
go
create  procedure `logout`(acursession varchar(38))/* идентификатор сессии */
body:   begin
declare
existscnt integer;
select count(*) into existscnt from the_session where the_sessionid=g2b(acursession) and closed=0;
if existscnt &gt;0 then
    update instance set locksessionid =null where locksessionid=acursession ;
    update the_session set closed=1,closedat=now(), changestamp=now() where 
    the_sessionid=g2b(acursession);
     delete from sysrefcache where sessionid= g2b(acursession);
 end if;
            end
go

drop function if exists getbrieffromxml
go
create function getbrieffromxml (axmlsource varchar(255))
returns varchar(255)
  deterministic 
body:begin
declare aoutstr  varchar(255);
declare afrom int;
declare ato int;
set afrom = charindex('&lt;brief&gt;', axmlsource);
set ato = charindex('&lt;/brief&gt;', axmlsource);
if (afrom &gt; 0 and ato &gt; 0) then
  set aoutstr = substring(axmlsource, afrom + 7, ato - afrom - 7);
else
  set aoutstr = '';
end if;
return aoutstr;
end
go

drop function if exists getidfromxml
go
create function getidfromxml (axmlsource varchar(255))
returns varchar(255)
 deterministic 
begin
declare aoutstr  varchar(255);
declare afrom  int;
declare ato  int;

set afrom = charindex('&lt;id&gt;', axmlsource);
set ato = charindex('&lt;/id&gt;', axmlsource);
if (afrom &gt; 0 and ato &gt; 0) then
  set aoutstr = substring(axmlsource, afrom + 4, ato - afrom - 4);
 else 
  set aoutstr = '';
end if;

return aoutstr;
end
go

drop procedure if exists instance_owner
go
create procedure instance_owner (  acursession varchar(38) ,ainstanceid varchar(38), aownerpartname varchar(255), aownerrowid varchar(38))
body:begin
declare aec  int;
select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
end if;
select count(*) into aec from instance where instanceid=g2b(ainstanceid);
if aec&gt;0 then
  if aownerpartname is null or aownerrowid is null then
     update instance set ownerpartname=null, ownerrowid = null where instanceid=g2b(ainstanceid);
  else
     update instance set ownerpartname=aownerpartname, ownerrowid = g2b(aownerrowid) where instanceid=g2b(ainstanceid);
  end if;
end if;
end
go


drop procedure if exists sysoptions_save
go
create procedure sysoptions_save ( asysoptionsid varchar(38), aname varchar(255),avalue varchar (255), aoptiontype varchar(255)) 
begin
declare aec  int;
select count(*) into aec from sysoptions where sysoptionsid=g2b(asysoptionsid);
if aec&gt;0 then
  update sysoptions set name=aname, value=avalue, optiontype=aoptiontype where sysoptionsid=g2b(asysoptionsid);
else
  insert into sysoptions (sysoptionsid, name, value, optiontype)values(g2b(asysoptionsid),aname,avalue,aoptiontype);
end if;
end
go


drop procedure if exists instance_save
go
create procedure instance_save (
acursession varchar(38),
ainstanceid varchar(38),
aobjtype varchar(255),
aname varchar(255)
) 
body:begin
 declare atmpstr varchar(255);
 declare assid binary(16);
 declare atmpid binary(16);
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare astatusid binary(16);
declare aec  int;
select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
end if;
select count(*) into aec from instance where instanceid=g2b(ainstanceid);
if aec&gt;0 then
   update instance set name = aname where  instanceid=g2b(ainstanceid);
else
    select count(*) into aec from typelist where name = aobjtype;
    if aec then
      start transaction;
      set astatusid=null;
      select objstatusid into astatusid from objstatus join bp3doc_def on
      bp3doc_def.objecttypeid=objstatus.parentstructrowid and bp3doc_def.name=aobjtype and isstartup&lt;&gt;0;
      if not astatusid is null then
        insert into instance(instanceid,name,objtype,status) values(g2b(ainstanceid),aname,aobjtype,g2b(astatusid));
      else 
        insert into instance(instanceid,name,objtype) values(g2b(ainstanceid),aname,aobjtype);
      end if; 
      commit;
    end if;
end if;
select 'ok' result;
end
go

drop procedure if exists instance_delete
go
create procedure instance_delete (
acursession varchar(38),
ainstanceid varchar(38)
)
body:begin
   declare aec  int;
select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
end if;
   select count(*) into aec from instance where instanceid=g2b(ainstanceid);
    if aec&gt;0 then
         delete from instance where instanceid=g2b(ainstanceid);
        end if;
end
go

drop procedure if exists instance_archive
go
create procedure instance_archive (
acursession varchar(38),
ainstanceid varchar(38)
)
body:begin
   declare aec  int;
select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
end if;
   select count(*) into aec from instance where instanceid=g2b(ainstanceid);
    if aec&gt;0 then
         update instance set archived=1 where instanceid=g2b(ainstanceid);
    end if;
end
go

drop procedure if exists instance_rearchive
go
create procedure instance_rearchive (
acursession varchar(38),
ainstanceid varchar(38)
)
body:begin
   declare aec  int;
select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
end if;
   select count(*) into aec from instance where instanceid=g2b(ainstanceid);
    if aec&gt;0 then
         update instance set archived=0 where instanceid=g2b(ainstanceid);
    end if;
end
go

drop procedure if exists instance_hcl
go
create procedure instance_hcl (
acursession varchar(38),
arowid varchar(38),
out aislocked int
) 
body:begin
declare atmpstr varchar(255);
declare aobjtype varchar(255);
   declare aec  int;
select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
end if;
   select count(*) into aec from instance where instanceid=g2b(ainstanceid);
    if aec&gt;0 then
    set aislocked=0;
    end if;
end
go

drop procedure if exists instance_islocked
go
 create  procedure instance_islocked (
 acursession varchar(38),
 arowid varchar(38) ,
 out aislocked integer 
) body:begin
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
   declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
end if;
   select count(*) into aec from instance where instanceid=g2b(arowid);
   if aec&gt;0 then
        select auserid = usersid  from the_session where the_sessionid=g2b(acursession);
        select alockuserid = lockuserid,alocksessionid = locksessionid from instance where instanceid=g2b(arowid);
        /* verify this row */
   if not alockuserid is null then
    if  alockuserid &lt;&gt; auserid then
      set aislocked = 4; /* checkout by another user */
      leave body;
    else
     set aislocked = 2; /* checkout by caller */
     leave body;
    end if;
   end if;
   if not alocksessionid is null then
        if  alocksessionid &lt;&gt; acursession then
            set aislocked = 3; /* lockes by another user */
            leave body;
        else
            set aislocked = 1; /* locked by caller */
            leave body;
        end if;
   end if;
  end if;
 end
go

drop procedure if exists qr_or_qr
go
create procedure qr_or_qr( aid1 varchar(38), aid2 varchar(38),aidout varchar(38),out acnt integer )
body:begin
delete from queryresult where queryresultid=g2b(aidout);
insert into queryresult(queryresultid,result)
select distinct aidout, result from queryresult where queryresultid in (aid1,aid2);
select acnt=count(*) from queryresult where queryresultid=g2b(aidout);
end
go

drop procedure if exists instance_lock
go
create  procedure instance_lock  (
 acursession varchar(38),
 arowid varchar(38) ,
 alockmode integer
) body:begin

 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aec  int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0  then
    leave body;
 end if;
 select count(*) into aec from instance where instanceid=g2b(arowid);
 if aec&gt;0 then
  select auserid = usersid  from the_session where the_sessionid=g2b(acursession);
  call instance_islocked( acursession,arowid,aislocked);
  if aislocked &gt;=3 then
    leave body;
  end if;
   if  alockmode =2 then
    update instance  set lockuserid =g2b(auserid ),locksessionid=null  where instanceid=g2b(arowid);
     leave body;
   end if;
   if  alockmode =1 then
    update instance  set lockuserid=null ,locksessionid =g2b(acursession)  where instanceid=g2b(arowid);
     leave body;
   end if;
end if;
 end

go

drop procedure if exists instance_unlock
go
create  procedure instance_unlock /*пользователи системы*/ (
 acursession varchar(38),
 arowid varchar(38)
) body:begin
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked int;
 declare aparenttable varchar(255);
 declare aec  int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0  then
    leave body;
 end if;
 select count(*) into aec from instance where instanceid=g2b(arowid);
 if aec&gt;0 then
 call instance_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3 then
    leave body;
  end if;
   if  aislocked =2 then
    update instance set lockuserid=null   where instanceid=g2b(arowid);
     leave body;
   end if;
   if  aislocked =1 then
    update instance set locksessionid=null   where instanceid=g2b(arowid);
     leave body;
   end if;
end if;
 end

go

drop procedure if exists instance_brief
go
  create procedure instance_brief  (
 acursession varchar(38),
 ainstanceid varchar(38),
 out abrief varchar(255)
) body:begin
 declare atmpstr varchar(255);
 declare aaccess int;
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare aec  int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0  then
    leave body;
 end if;
 if ainstanceid is null then set abrief=''; leave body; end if;
 select count(*) into aec from instance where instanceid=g2b(ainstanceid);
 if aec&gt;0 then
   select concat(ifnull(name,''),'; ',ifnull(objtype,'')) into abrief 
   from instance  where  instanceid = g2b(ainstanceid);
 else 
   set abrief= 'неверный идентификатор';
end if;
end

go

drop procedure if exists rowparents
go
create  procedure rowparents
        (aqueryid varchar(38)
        ,arowid varchar(38)
        ,atable varchar (255)
        ,acursession varchar(38)
        )
body:   begin
declare aplevel integer;
declare aparent varchar(255);
declare aprev varchar(255);
declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0  then
    leave body;
  end if;
set aparent =atable;
set @_tmpid = g2b(arowid);
set aplevel =0;
delete from rpresult where rpresultid  =g2b(aqueryid);
insert into rpresult(rpresultid,parentlevel,partname,rowid)values(g2b(aqueryid),aplevel,atable,g2b(arowid));
again:loop
set aplevel =aplevel + 1;
set aprev = aparent;
set aparent = null;
select value into aparent from sysoptions where optiontype ='parent' and  name=aprev;
 if aparent is null then
    set @_ss = concat('select instanceid into @_tmprowid from ' , aprev , ' where ' ,aprev ,'id=?');
    prepare stmt from @_ss;
    execute stmt using @_tmpid;
    deallocate prepare stmt;
   insert into rpresult(rpresultid,parentlevel,partname,rowid)values(g2b(aqueryid),aplevel,'instance',@_tmprowid);
   leave again;
 else 
    set @_ss = concat('select parentstructrowid  into @_tmprowid from ' , aprev , ' where ' ,aprev ,'id=?');
    prepare stmt from @_ss;
    execute stmt using @_tmpid;
    deallocate prepare stmt;
    set @_tmpid = @_tmprowid;
   insert into rpresult(rpresultid,parentlevel,partname,rowid)
   values(g2b(aqueryid),aplevel,aparent,@_tmprowid);
 end if;
end loop again;
end 
go
">
      <FormData Name="" />
    </BlockHolder>
  </ModuleHolder>
  <ModuleHolder ModuleName="--Procedures" File="">
    <BlockHolder BlockName="--TableProc" BlockCode=" 


drop procedure if exists bp3ft_def_brief
go

create procedure bp3ft_def_brief  (
 acursession varchar(38),
 abp3ft_defid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if abp3ft_defid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from bp3ft_def where bp3ft_defid=g2b(abp3ft_defid);
 if  aec &gt;0 then
   set abrief=bp3ft_def_brief_f(g2b(abp3ft_defid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists bp3ft_def_delete
go

create procedure bp3ft_def_delete /*тип полея, перечисления, интервалы*/ (
 acursession varchar(38),
 abp3ft_defid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3ft_def where bp3ft_defid=g2b(abp3ft_defid);
if aec&gt;0 then
 select checkoperation( acursession ,'bp3ft.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=bp3ft_def' result;
    leave body;
  end if;
 call bp3ft_def_logger(acursession,abp3ft_defid) ; 
  delete from  bp3ft_def 
  where  bp3ft_defid = g2b(abp3ft_defid) ;
  delete from num_values where ownerpartname='bp3ft_def' and ownerrowid=g2b(abp3ft_defid);
  end if;
    select 'ok' result;
 end 
go
GO

/*тип поля*/

drop procedure if exists bp3ft_def_save
go

create procedure bp3ft_def_save /*тип полея, перечисления, интервалы*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 abp3ft_defid varchar(38)
,adelayedsave
 integer/* отложенное сохранение *//* отложенное сохранение */
,atypestyle
 integer/* трактовка *//* трактовка */
,aname
 varchar (255)/* название *//* название */
,agridsorttype
 integer/* вариант сортировки в табличном представлении *//* вариант сортировки в табличном представлении */
,athe_comment
 text/* описание *//* описание */
,aallowsize
 integer/* нужен размер *//* нужен размер */
,aallowlikesearch
 integer/* поиск текста *//* поиск текста */
,amaximum
 varchar (64)/* максимум *//* максимум */
,aminimum
 varchar (64)/* минимум *//* минимум */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3ft_def where bp3ft_defid=g2b(abp3ft_defid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'bp3ft.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=bp3ft_def' result;
    leave body;
  end if;
 start transaction ; 
 call bp3ft_def_logger(acursession,abp3ft_defid) ; 
 update  bp3ft_def set changestamp=now()
,
  delayedsave=adelayedsave
,
  typestyle=atypestyle
,
  name=aname
,
  gridsorttype=agridsorttype
,
  the_comment=athe_comment
,
  allowsize=aallowsize
,
  allowlikesearch=aallowlikesearch
,
  maximum=amaximum
,
  minimum=aminimum
  where  bp3ft_defid = g2b(abp3ft_defid) ;


call bp3ft_def_client_trigger(acursession,abp3ft_defid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'bp3ft.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=bp3ft_def' result;
    leave body;
  end if;
select count(*) into aec from bp3ft_def where 
instanceid=g2b(ainstanceid);
if aec &gt;0 then 
    select 'невозможно создать вторую строку в однострочной сессии. раздел: &lt;bp3ft_def&gt;' result;
    rollback;
    leave body;
 end if;
 start transaction;  
 insert into   bp3ft_def
 (  bp3ft_defid 
,instanceid
,delayedsave

,typestyle

,name

,gridsorttype

,the_comment

,allowsize

,allowlikesearch

,maximum

,minimum

 ) values ( g2b(abp3ft_defid) 
,g2b(ainstanceid)
,adelayedsave

,atypestyle

,aname

,agridsorttype

,athe_comment

,aallowsize

,aallowlikesearch

,amaximum

,aminimum

 ) ;


call bp3ft_def_client_trigger(acursession,abp3ft_defid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists bp3ft_def_copy
go

create procedure bp3ft_def_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into bp3ft_def 
 ( bp3ft_defid 
,instanceid
,delayedsave

,typestyle

,name

,gridsorttype

,the_comment

,allowsize

,allowlikesearch

,maximum

,minimum

 ) select 
copymap(acopyaction,b2g(bp3ft_defid)) 
,copymap(acopyaction,b2g(instanceid))
,delayedsave

,typestyle

,name

,gridsorttype

,the_comment

,allowsize

,allowlikesearch

,maximum

,minimum

 from bp3ft_def
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists bp3ft_def_logger
go

create procedure bp3ft_def_logger /*тип полея, перечисления, интервалы*/ (
 acursession varchar(38),
 abp3ft_defid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists bp3ft_def_parent
go
create procedure bp3ft_def_parent /* тип полея, перечисления, интервалы*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from bp3ft_def where  bp3ft_defid=arowid;
 end 
go
GO


drop procedure if exists bp3ft_def_islocked
go
create procedure bp3ft_def_islocked /* тип полея, перечисления, интервалы */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from bp3ft_def where bp3ft_defid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists bp3ft_def_lock
go
create procedure bp3ft_def_lock /* тип полея, перечисления, интервалы */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call bp3ft_def_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update bp3ft_def set lockuserid =auserid ,locksessionid=null  where bp3ft_defid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update bp3ft_def set lockuserid=null ,locksessionid =acursession  where bp3ft_defid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists bp3ft_def_unlock
go
create procedure bp3ft_def_unlock /* тип полея, перечисления, интервалы */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call bp3ft_def_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update bp3ft_def set lockuserid =null  where bp3ft_defid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update bp3ft_def set locksessionid =null  where bp3ft_defid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS bp3ft_def_client_trigger
GO

create procedure bp3ft_def_client_trigger  (
 acursession varchar(38),
 abp3ft_defid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists bp3ft_map_brief
go

create procedure bp3ft_map_brief  (
 acursession varchar(38),
 abp3ft_mapid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if abp3ft_mapid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from bp3ft_map where bp3ft_mapid=g2b(abp3ft_mapid);
 if  aec &gt;0 then
   set abrief=bp3ft_map_brief_f(g2b(abp3ft_mapid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists bp3ft_map_delete
go

create procedure bp3ft_map_delete /*отображение типа поля на физический тип хранения*/ (
 acursession varchar(38),
 abp3ft_mapid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3ft_map where bp3ft_mapid=g2b(abp3ft_mapid);
if aec&gt;0 then
 select checkoperation( acursession ,'bp3ft.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=bp3ft_map' result;
    leave body;
  end if;
 call bp3ft_map_logger(acursession,abp3ft_mapid) ; 
  delete from  bp3ft_map 
  where  bp3ft_mapid = g2b(abp3ft_mapid) ;
  delete from num_values where ownerpartname='bp3ft_map' and ownerrowid=g2b(abp3ft_mapid);
  end if;
    select 'ok' result;
 end 
go
GO

/*отображение*/

drop procedure if exists bp3ft_map_save
go

create procedure bp3ft_map_save /*отображение типа поля на физический тип хранения*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 abp3ft_mapid varchar(38)
,afixedsize
 integer/* размер *//* размер */
,astoagetype
 varchar (255)/* тип хранения *//* тип хранения */
,atarget varchar(38)/* платформа *//* платформа */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3ft_map where bp3ft_mapid=g2b(abp3ft_mapid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'bp3ft.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=bp3ft_map' result;
    leave body;
  end if;
 start transaction ; 
 call bp3ft_map_logger(acursession,abp3ft_mapid) ; 
 update  bp3ft_map set changestamp=now()
,
  fixedsize=afixedsize
,
  stoagetype=astoagetype
,
  target=g2b(atarget)
  where  bp3ft_mapid = g2b(abp3ft_mapid) ;


call bp3ft_map_client_trigger(acursession,abp3ft_mapid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'bp3ft.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=bp3ft_map' result;
    leave body;
  end if;
 start transaction;  
 insert into   bp3ft_map
 (  bp3ft_mapid 
,instanceid
,fixedsize

,stoagetype

,target

 ) values ( g2b(abp3ft_mapid) 
,g2b(ainstanceid)
,afixedsize

,astoagetype

,g2b(atarget)

 ) ;


call bp3ft_map_client_trigger(acursession,abp3ft_mapid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists bp3ft_map_copy
go

create procedure bp3ft_map_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into bp3ft_map 
 ( bp3ft_mapid 
,instanceid
,fixedsize

,stoagetype

,target

 ) select 
copymap(acopyaction,b2g(bp3ft_mapid)) 
,copymap(acopyaction,b2g(instanceid))
,fixedsize

,stoagetype

,target

 from bp3ft_map
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists bp3ft_map_logger
go

create procedure bp3ft_map_logger /*отображение типа поля на физический тип хранения*/ (
 acursession varchar(38),
 abp3ft_mapid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists bp3ft_map_parent
go
create procedure bp3ft_map_parent /* отображение типа поля на физический тип хранения*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from bp3ft_map where  bp3ft_mapid=arowid;
 end 
go
GO


drop procedure if exists bp3ft_map_islocked
go
create procedure bp3ft_map_islocked /* отображение типа поля на физический тип хранения */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from bp3ft_map where bp3ft_mapid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists bp3ft_map_lock
go
create procedure bp3ft_map_lock /* отображение типа поля на физический тип хранения */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call bp3ft_map_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update bp3ft_map set lockuserid =auserid ,locksessionid=null  where bp3ft_mapid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update bp3ft_map set lockuserid=null ,locksessionid =acursession  where bp3ft_mapid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists bp3ft_map_unlock
go
create procedure bp3ft_map_unlock /* отображение типа поля на физический тип хранения */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call bp3ft_map_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update bp3ft_map set lockuserid =null  where bp3ft_mapid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update bp3ft_map set locksessionid =null  where bp3ft_mapid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS bp3ft_map_client_trigger
GO

create procedure bp3ft_map_client_trigger  (
 acursession varchar(38),
 abp3ft_mapid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists bp3ft_enums_brief
go

create procedure bp3ft_enums_brief  (
 acursession varchar(38),
 abp3ft_enumsid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if abp3ft_enumsid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from bp3ft_enums where bp3ft_enumsid=g2b(abp3ft_enumsid);
 if  aec &gt;0 then
   set abrief=bp3ft_enums_brief_f(g2b(abp3ft_enumsid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists bp3ft_enums_delete
go

create procedure bp3ft_enums_delete /*для описания enum типов*/ (
 acursession varchar(38),
 abp3ft_enumsid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3ft_enums where bp3ft_enumsid=g2b(abp3ft_enumsid);
if aec&gt;0 then
 select checkoperation( acursession ,'bp3ft.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=bp3ft_enums' result;
    leave body;
  end if;
 call bp3ft_enums_logger(acursession,abp3ft_enumsid) ; 
  delete from  bp3ft_enums 
  where  bp3ft_enumsid = g2b(abp3ft_enumsid) ;
  delete from num_values where ownerpartname='bp3ft_enums' and ownerrowid=g2b(abp3ft_enumsid);
  end if;
    select 'ok' result;
 end 
go
GO

/*зачения*/

drop procedure if exists bp3ft_enums_save
go

create procedure bp3ft_enums_save /*для описания enum типов*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 abp3ft_enumsid varchar(38)
,aname
 varchar (255)/* название *//* название */
,anameincode
 varchar (100)/* название в коде *//* название в коде */
,anamevalue
 integer/* значение *//* значение */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3ft_enums where bp3ft_enumsid=g2b(abp3ft_enumsid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'bp3ft.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=bp3ft_enums' result;
    leave body;
  end if;
 start transaction ; 
 call bp3ft_enums_logger(acursession,abp3ft_enumsid) ; 
 update  bp3ft_enums set changestamp=now()
,
  name=aname
,
  nameincode=anameincode
,
  namevalue=anamevalue
  where  bp3ft_enumsid = g2b(abp3ft_enumsid) ;


call bp3ft_enums_client_trigger(acursession,abp3ft_enumsid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'bp3ft.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=bp3ft_enums' result;
    leave body;
  end if;
 start transaction;  
 insert into   bp3ft_enums
 (  bp3ft_enumsid 
,instanceid
,name

,nameincode

,namevalue

 ) values ( g2b(abp3ft_enumsid) 
,g2b(ainstanceid)
,aname

,anameincode

,anamevalue

 ) ;


call bp3ft_enums_client_trigger(acursession,abp3ft_enumsid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists bp3ft_enums_copy
go

create procedure bp3ft_enums_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into bp3ft_enums 
 ( bp3ft_enumsid 
,instanceid
,name

,nameincode

,namevalue

 ) select 
copymap(acopyaction,b2g(bp3ft_enumsid)) 
,copymap(acopyaction,b2g(instanceid))
,name

,nameincode

,namevalue

 from bp3ft_enums
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists bp3ft_enums_logger
go

create procedure bp3ft_enums_logger /*для описания enum типов*/ (
 acursession varchar(38),
 abp3ft_enumsid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists bp3ft_enums_parent
go
create procedure bp3ft_enums_parent /* для описания enum типов*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from bp3ft_enums where  bp3ft_enumsid=arowid;
 end 
go
GO


drop procedure if exists bp3ft_enums_islocked
go
create procedure bp3ft_enums_islocked /* для описания enum типов */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from bp3ft_enums where bp3ft_enumsid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists bp3ft_enums_lock
go
create procedure bp3ft_enums_lock /* для описания enum типов */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call bp3ft_enums_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update bp3ft_enums set lockuserid =auserid ,locksessionid=null  where bp3ft_enumsid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update bp3ft_enums set lockuserid=null ,locksessionid =acursession  where bp3ft_enumsid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists bp3ft_enums_unlock
go
create procedure bp3ft_enums_unlock /* для описания enum типов */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call bp3ft_enums_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update bp3ft_enums set lockuserid =null  where bp3ft_enumsid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update bp3ft_enums set locksessionid =null  where bp3ft_enumsid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS bp3ft_enums_client_trigger
GO

create procedure bp3ft_enums_client_trigger  (
 acursession varchar(38),
 abp3ft_enumsid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists bp3app_modules_brief
go

create procedure bp3app_modules_brief  (
 acursession varchar(38),
 abp3app_modulesid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if abp3app_modulesid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from bp3app_modules where bp3app_modulesid=g2b(abp3app_modulesid);
 if  aec &gt;0 then
   set abrief=bp3app_modules_brief_f(g2b(abp3app_modulesid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists bp3app_modules_delete
go

create procedure bp3app_modules_delete /*пункты главного меню*/ (
 acursession varchar(38),
 abp3app_modulesid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3app_modules where bp3app_modulesid=g2b(abp3app_modulesid);
if aec&gt;0 then
 select checkoperation( acursession ,'bp3app.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=bp3app_modules' result;
    leave body;
  end if;
 call bp3app_modules_logger(acursession,abp3app_modulesid) ; 
  delete from  bp3app_modules 
  where  bp3app_modulesid = g2b(abp3app_modulesid) ;
  delete from num_values where ownerpartname='bp3app_modules' and ownerrowid=g2b(abp3app_modulesid);
  end if;
    select 'ok' result;
 end 
go
GO

/*модули*/

drop procedure if exists bp3app_modules_save
go

create procedure bp3app_modules_save /*пункты главного меню*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 abp3app_modulesid varchar(38)
,atopmenu varchar(38)/* меню *//* меню */
,agroupname
 varchar (60)/* имя группы *//* имя группы */
,acaption
 varchar (80)/* надпись *//* надпись */
,aname
 varchar (64)/* код модуля *//* код модуля */
,asequence
 integer/* № п/п *//* № п/п */
,athecomment
 text/* описание *//* описание */
,atheicon
 varchar (64)/* иконка *//* иконка */
,acustomizevisibility
 integer/* настраивать видимость *//* настраивать видимость */
,ajournal varchar(38)/* журнал *//* журнал */
,adocument varchar(38)/* документ *//* документ */
,aactiontype
 integer/* вариант действия *//* вариант действия */
,aobjecttype varchar(38)/* тип документа *//* тип документа */
,areport varchar(38)/* отчет *//* отчет */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3app_modules where bp3app_modulesid=g2b(abp3app_modulesid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'bp3app.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=bp3app_modules' result;
    leave body;
  end if;
 start transaction ; 
 call bp3app_modules_logger(acursession,abp3app_modulesid) ; 
 update  bp3app_modules set changestamp=now()
,
  topmenu=g2b(atopmenu)
,
  groupname=agroupname
,
  caption=acaption
,
  name=aname
,
  sequence=asequence
,
  thecomment=athecomment
,
  theicon=atheicon
,
  customizevisibility=acustomizevisibility
,
  journal=g2b(ajournal)
,
  document=g2b(adocument)
,
  actiontype=aactiontype
,
  objecttype=g2b(aobjecttype)
,
  report=g2b(areport)
  where  bp3app_modulesid = g2b(abp3app_modulesid) ;


call bp3app_modules_client_trigger(acursession,abp3app_modulesid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'bp3app.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=bp3app_modules' result;
    leave body;
  end if;
 start transaction;  
 insert into   bp3app_modules
 (  bp3app_modulesid 
,instanceid
,topmenu

,groupname

,caption

,name

,sequence

,thecomment

,theicon

,customizevisibility

,journal

,document

,actiontype

,objecttype

,report

 ) values ( g2b(abp3app_modulesid) 
,g2b(ainstanceid)
,g2b(atopmenu)

,agroupname

,acaption

,aname

,asequence

,athecomment

,atheicon

,acustomizevisibility

,g2b(ajournal)

,g2b(adocument)

,aactiontype

,g2b(aobjecttype)

,g2b(areport)

 ) ;


call bp3app_modules_client_trigger(acursession,abp3app_modulesid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists bp3app_oper_brief
go

create procedure bp3app_oper_brief  (
 acursession varchar(38),
 abp3app_operid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if abp3app_operid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from bp3app_oper where bp3app_operid=g2b(abp3app_operid);
 if  aec &gt;0 then
   set abrief=bp3app_oper_brief_f(g2b(abp3app_operid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists bp3app_oper_delete
go

create procedure bp3app_oper_delete /*действия и отчеты*/ (
 acursession varchar(38),
 abp3app_operid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3app_oper where bp3app_operid=g2b(abp3app_operid);
if aec&gt;0 then
 select checkoperation( acursession ,'bp3app.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=bp3app_oper' result;
    leave body;
  end if;
 call bp3app_oper_logger(acursession,abp3app_operid) ; 
  delete from  bp3app_oper 
  where  bp3app_operid = g2b(abp3app_operid) ;
  delete from num_values where ownerpartname='bp3app_oper' and ownerrowid=g2b(abp3app_operid);
  end if;
    select 'ok' result;
 end 
go
GO

/*действия и отчеты*/

drop procedure if exists bp3app_oper_save
go

create procedure bp3app_oper_save /*действия и отчеты*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 abp3app_operid varchar(38)
,arighttype varchar(38)/* тип права *//* тип права */
,acaption
 varchar (80)/* надпись *//* надпись */
,aname
 varchar (64)/* код *//* код */
,asequence
 integer/* № п/п *//* № п/п */
,atheicon
 varchar (64)/* иконка *//* иконка */
,aisreport
 integer/* это отчет *//* это отчет */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3app_oper where bp3app_operid=g2b(abp3app_operid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'bp3app.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=bp3app_oper' result;
    leave body;
  end if;
 start transaction ; 
 call bp3app_oper_logger(acursession,abp3app_operid) ; 
 update  bp3app_oper set changestamp=now()
,
  righttype=g2b(arighttype)
,
  caption=acaption
,
  name=aname
,
  sequence=asequence
,
  theicon=atheicon
,
  isreport=aisreport
  where  bp3app_operid = g2b(abp3app_operid) ;


call bp3app_oper_client_trigger(acursession,abp3app_operid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'bp3app.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=bp3app_oper' result;
    leave body;
  end if;
 start transaction;  
 insert into   bp3app_oper
 (  bp3app_operid 
,parentstructrowid
,righttype

,caption

,name

,sequence

,theicon

,isreport

 ) values ( g2b(abp3app_operid) 
,g2b(aparentstructrowid)
,g2b(arighttype)

,acaption

,aname

,asequence

,atheicon

,aisreport

 ) ;


call bp3app_oper_client_trigger(acursession,abp3app_operid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists bp3app_oper_copy
go

create procedure bp3app_oper_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into bp3app_oper 
 ( bp3app_operid 
,parentstructrowid
,righttype

,caption

,name

,sequence

,theicon

,isreport

 ) select 
copymap(acopyaction,b2g(bp3app_operid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,righttype

,caption

,name

,sequence

,theicon

,isreport

 from bp3app_oper
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists bp3app_modules_copy
go

create procedure bp3app_modules_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
declare aid binary(16);
declare fetch_done int default false;
declare copy_cursor_bp3app_modules cursor for
select bp3app_modulesid from bp3app_modules where 
instanceid =ainstanceid;
 declare continue handler for not found set fetch_done = true;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into bp3app_modules 
 ( bp3app_modulesid 
,instanceid
,topmenu

,groupname

,caption

,name

,sequence

,thecomment

,theicon

,customizevisibility

,journal

,document

,actiontype

,objecttype

,report

 ) select 
copymap(acopyaction,b2g(bp3app_modulesid)) 
,copymap(acopyaction,b2g(instanceid))
,topmenu

,groupname

,caption

,name

,sequence

,thecomment

,theicon

,customizevisibility

,journal

,document

,actiontype

,objecttype

,report

 from bp3app_modules
 where instanceid =g2b( ainstanceid); 
open copy_cursor_bp3app_modules;
  set  fetch_done=false;
fetch copy_cursor_bp3app_modules into aid;
while not fetch_done do 
    call bp3app_oper_copy(acursession,acopyaction,ainstanceid,aid);
  set  fetch_done=false;
    fetch copy_cursor_bp3app_modules into aid;
end while;

close copy_cursor_bp3app_modules;
 end 
go
GO


drop procedure if exists bp3app_modules_logger
go

create procedure bp3app_modules_logger /*пункты главного меню*/ (
 acursession varchar(38),
 abp3app_modulesid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists bp3app_oper_logger
go

create procedure bp3app_oper_logger /*действия и отчеты*/ (
 acursession varchar(38),
 abp3app_operid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists bp3app_modules_parent
go
create procedure bp3app_modules_parent /* пункты главного меню*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from bp3app_modules where  bp3app_modulesid=arowid;
 end 
go
GO


drop procedure if exists bp3app_modules_islocked
go
create procedure bp3app_modules_islocked /* пункты главного меню */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from bp3app_modules where bp3app_modulesid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists bp3app_modules_lock
go
create procedure bp3app_modules_lock /* пункты главного меню */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call bp3app_modules_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update bp3app_modules set lockuserid =auserid ,locksessionid=null  where bp3app_modulesid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update bp3app_modules set lockuserid=null ,locksessionid =acursession  where bp3app_modulesid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists bp3app_modules_unlock
go
create procedure bp3app_modules_unlock /* пункты главного меню */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call bp3app_modules_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update bp3app_modules set lockuserid =null  where bp3app_modulesid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update bp3app_modules set locksessionid =null  where bp3app_modulesid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS bp3app_modules_client_trigger
GO

create procedure bp3app_modules_client_trigger  (
 acursession varchar(38),
 aBP3APP_MODULESid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists bp3app_oper_parent
go
create procedure bp3app_oper_parent /* действия и отчеты*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from bp3app_oper where  bp3app_operid=arowid;
  set aparenttable = 'bp3app_modules';
 end 
go
GO


drop procedure if exists bp3app_oper_islocked
go
create procedure bp3app_oper_islocked /* действия и отчеты */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from bp3app_oper where bp3app_operid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists bp3app_oper_lock
go
create procedure bp3app_oper_lock /* действия и отчеты */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call bp3app_oper_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update bp3app_oper set lockuserid =auserid ,locksessionid=null  where bp3app_operid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update bp3app_oper set lockuserid=null ,locksessionid =acursession  where bp3app_operid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists bp3app_oper_unlock
go
create procedure bp3app_oper_unlock /* действия и отчеты */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call bp3app_oper_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update bp3app_oper set lockuserid =null  where bp3app_operid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update bp3app_oper set locksessionid =null  where bp3app_operid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS bp3app_oper_client_trigger
GO

create procedure bp3app_oper_client_trigger  (
 acursession varchar(38),
 aBP3APP_OPERid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists bp3app_menu_brief
go

create procedure bp3app_menu_brief  (
 acursession varchar(38),
 abp3app_menuid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if abp3app_menuid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from bp3app_menu where bp3app_menuid=g2b(abp3app_menuid);
 if  aec &gt;0 then
   set abrief=bp3app_menu_brief_f(g2b(abp3app_menuid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists bp3app_menu_delete
go

create procedure bp3app_menu_delete /**/ (
 acursession varchar(38),
 abp3app_menuid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3app_menu where bp3app_menuid=g2b(abp3app_menuid);
if aec&gt;0 then
 select checkoperation( acursession ,'bp3app.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=bp3app_menu' result;
    leave body;
  end if;
 call bp3app_menu_logger(acursession,abp3app_menuid) ; 
  delete from  bp3app_menu 
  where  bp3app_menuid = g2b(abp3app_menuid) ;
  delete from num_values where ownerpartname='bp3app_menu' and ownerrowid=g2b(abp3app_menuid);
  end if;
    select 'ok' result;
 end 
go
GO

/*меню*/

drop procedure if exists bp3app_menu_save
go

create procedure bp3app_menu_save /**/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 abp3app_menuid varchar(38)
,acaption
 varchar (80)/* надпись *//* надпись */
,aname
 varchar (64)/* код модуля *//* код модуля */
,asequence
 integer/* № п/п *//* № п/п */
,atheicon
 varchar (64)/* иконка *//* иконка */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3app_menu where bp3app_menuid=g2b(abp3app_menuid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'bp3app.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=bp3app_menu' result;
    leave body;
  end if;
 start transaction ; 
 call bp3app_menu_logger(acursession,abp3app_menuid) ; 
 update  bp3app_menu set changestamp=now()
,
  caption=acaption
,
  name=aname
,
  sequence=asequence
,
  theicon=atheicon
  where  bp3app_menuid = g2b(abp3app_menuid) ;


call bp3app_menu_client_trigger(acursession,abp3app_menuid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'bp3app.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=bp3app_menu' result;
    leave body;
  end if;
 start transaction;  
 insert into   bp3app_menu
 (  bp3app_menuid 
,instanceid
,caption

,name

,sequence

,theicon

 ) values ( g2b(abp3app_menuid) 
,g2b(ainstanceid)
,acaption

,aname

,asequence

,atheicon

 ) ;


call bp3app_menu_client_trigger(acursession,abp3app_menuid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists bp3app_menu_copy
go

create procedure bp3app_menu_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into bp3app_menu 
 ( bp3app_menuid 
,instanceid
,caption

,name

,sequence

,theicon

 ) select 
copymap(acopyaction,b2g(bp3app_menuid)) 
,copymap(acopyaction,b2g(instanceid))
,caption

,name

,sequence

,theicon

 from bp3app_menu
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists bp3app_menu_logger
go

create procedure bp3app_menu_logger /**/ (
 acursession varchar(38),
 abp3app_menuid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists bp3app_menu_parent
go
create procedure bp3app_menu_parent /* */ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from bp3app_menu where  bp3app_menuid=arowid;
 end 
go
GO


drop procedure if exists bp3app_menu_islocked
go
create procedure bp3app_menu_islocked /*  */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from bp3app_menu where bp3app_menuid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists bp3app_menu_lock
go
create procedure bp3app_menu_lock /*  */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call bp3app_menu_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update bp3app_menu set lockuserid =auserid ,locksessionid=null  where bp3app_menuid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update bp3app_menu set lockuserid=null ,locksessionid =acursession  where bp3app_menuid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists bp3app_menu_unlock
go
create procedure bp3app_menu_unlock /*  */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call bp3app_menu_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update bp3app_menu set lockuserid =null  where bp3app_menuid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update bp3app_menu set locksessionid =null  where bp3app_menuid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS bp3app_menu_client_trigger
GO

create procedure bp3app_menu_client_trigger  (
 acursession varchar(38),
 aBP3APP_MENUid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists bp3app_rigthtype_brief
go

create procedure bp3app_rigthtype_brief  (
 acursession varchar(38),
 abp3app_rigthtypeid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if abp3app_rigthtypeid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from bp3app_rigthtype where bp3app_rigthtypeid=g2b(abp3app_rigthtypeid);
 if  aec &gt;0 then
   set abrief=bp3app_rigthtype_brief_f(g2b(abp3app_rigthtypeid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists bp3app_rigthtype_delete
go

create procedure bp3app_rigthtype_delete /*тип права*/ (
 acursession varchar(38),
 abp3app_rigthtypeid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3app_rigthtype where bp3app_rigthtypeid=g2b(abp3app_rigthtypeid);
if aec&gt;0 then
 select checkoperation( acursession ,'bp3app.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=bp3app_rigthtype' result;
    leave body;
  end if;
 call bp3app_rigthtype_logger(acursession,abp3app_rigthtypeid) ; 
  delete from  bp3app_rigthtype 
  where  bp3app_rigthtypeid = g2b(abp3app_rigthtypeid) ;
  delete from num_values where ownerpartname='bp3app_rigthtype' and ownerrowid=g2b(abp3app_rigthtypeid);
  end if;
    select 'ok' result;
 end 
go
GO

/*тип права*/

drop procedure if exists bp3app_rigthtype_save
go

create procedure bp3app_rigthtype_save /*тип права*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 abp3app_rigthtypeid varchar(38)
,aname
 varchar (50)/* название *//* название */
,alistsortorder
 integer/* порядок вывода *//* порядок вывода */
,ashortname
 varchar (20)/* краткое название *//* краткое название */
,aselecttype
 integer/* вариант выбора *//* вариант выбора */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3app_rigthtype where bp3app_rigthtypeid=g2b(abp3app_rigthtypeid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'bp3app.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=bp3app_rigthtype' result;
    leave body;
  end if;
 start transaction ; 
 call bp3app_rigthtype_logger(acursession,abp3app_rigthtypeid) ; 
 update  bp3app_rigthtype set changestamp=now()
,
  name=aname
,
  listsortorder=alistsortorder
,
  shortname=ashortname
,
  selecttype=aselecttype
  where  bp3app_rigthtypeid = g2b(abp3app_rigthtypeid) ;


call bp3app_rigthtype_client_trigger(acursession,abp3app_rigthtypeid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'bp3app.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=bp3app_rigthtype' result;
    leave body;
  end if;
 start transaction;  
 insert into   bp3app_rigthtype
 (  bp3app_rigthtypeid 
,instanceid
,name

,listsortorder

,shortname

,selecttype

 ) values ( g2b(abp3app_rigthtypeid) 
,g2b(ainstanceid)
,aname

,alistsortorder

,ashortname

,aselecttype

 ) ;


call bp3app_rigthtype_client_trigger(acursession,abp3app_rigthtypeid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists bp3app_rigthtype_copy
go

create procedure bp3app_rigthtype_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into bp3app_rigthtype 
 ( bp3app_rigthtypeid 
,instanceid
,name

,listsortorder

,shortname

,selecttype

 ) select 
copymap(acopyaction,b2g(bp3app_rigthtypeid)) 
,copymap(acopyaction,b2g(instanceid))
,name

,listsortorder

,shortname

,selecttype

 from bp3app_rigthtype
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists bp3app_rigthtype_logger
go

create procedure bp3app_rigthtype_logger /*тип права*/ (
 acursession varchar(38),
 abp3app_rigthtypeid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists bp3app_rigthtype_parent
go
create procedure bp3app_rigthtype_parent /* тип права*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from bp3app_rigthtype where  bp3app_rigthtypeid=arowid;
 end 
go
GO


drop procedure if exists bp3app_rigthtype_islocked
go
create procedure bp3app_rigthtype_islocked /* тип права */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from bp3app_rigthtype where bp3app_rigthtypeid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists bp3app_rigthtype_lock
go
create procedure bp3app_rigthtype_lock /* тип права */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call bp3app_rigthtype_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update bp3app_rigthtype set lockuserid =auserid ,locksessionid=null  where bp3app_rigthtypeid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update bp3app_rigthtype set lockuserid=null ,locksessionid =acursession  where bp3app_rigthtypeid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists bp3app_rigthtype_unlock
go
create procedure bp3app_rigthtype_unlock /* тип права */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call bp3app_rigthtype_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update bp3app_rigthtype set lockuserid =null  where bp3app_rigthtypeid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update bp3app_rigthtype set locksessionid =null  where bp3app_rigthtypeid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS bp3app_rigthtype_client_trigger
GO

create procedure bp3app_rigthtype_client_trigger  (
 acursession varchar(38),
 aBP3APP_RIGTHTYPEid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists bp3app_info_brief
go

create procedure bp3app_info_brief  (
 acursession varchar(38),
 abp3app_infoid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if abp3app_infoid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from bp3app_info where bp3app_infoid=g2b(abp3app_infoid);
 if  aec &gt;0 then
   set abrief=bp3app_info_brief_f(g2b(abp3app_infoid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists bp3app_info_delete
go

create procedure bp3app_info_delete /**/ (
 acursession varchar(38),
 abp3app_infoid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3app_info where bp3app_infoid=g2b(abp3app_infoid);
if aec&gt;0 then
 select checkoperation( acursession ,'bp3app.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=bp3app_info' result;
    leave body;
  end if;
 call bp3app_info_logger(acursession,abp3app_infoid) ; 
  delete from  bp3app_info 
  where  bp3app_infoid = g2b(abp3app_infoid) ;
  delete from num_values where ownerpartname='bp3app_info' and ownerrowid=g2b(abp3app_infoid);
  end if;
    select 'ok' result;
 end 
go
GO

/*описание*/

drop procedure if exists bp3app_info_save
go

create procedure bp3app_info_save /**/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 abp3app_infoid varchar(38)
,aname
 varchar (120)/* название *//* название */
,aversion
 integer/* версия *//* версия */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3app_info where bp3app_infoid=g2b(abp3app_infoid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'bp3app.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=bp3app_info' result;
    leave body;
  end if;
 start transaction ; 
 call bp3app_info_logger(acursession,abp3app_infoid) ; 
 update  bp3app_info set changestamp=now()
,
  name=aname
,
  version=aversion
  where  bp3app_infoid = g2b(abp3app_infoid) ;


call bp3app_info_client_trigger(acursession,abp3app_infoid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'bp3app.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=bp3app_info' result;
    leave body;
  end if;
select count(*) into aec from bp3app_info where 
instanceid=g2b(ainstanceid);
if aec &gt;0 then 
    select 'невозможно создать вторую строку в однострочной сессии. раздел: &lt;bp3app_info&gt;' result;
    rollback;
    leave body;
 end if;
 start transaction;  
 insert into   bp3app_info
 (  bp3app_infoid 
,instanceid
,name

,version

 ) values ( g2b(abp3app_infoid) 
,g2b(ainstanceid)
,aname

,aversion

 ) ;


call bp3app_info_client_trigger(acursession,abp3app_infoid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists bp3app_info_copy
go

create procedure bp3app_info_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into bp3app_info 
 ( bp3app_infoid 
,instanceid
,name

,version

 ) select 
copymap(acopyaction,b2g(bp3app_infoid)) 
,copymap(acopyaction,b2g(instanceid))
,name

,version

 from bp3app_info
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists bp3app_info_logger
go

create procedure bp3app_info_logger /**/ (
 acursession varchar(38),
 abp3app_infoid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists bp3app_info_parent
go
create procedure bp3app_info_parent /* */ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from bp3app_info where  bp3app_infoid=arowid;
 end 
go
GO


drop procedure if exists bp3app_info_islocked
go
create procedure bp3app_info_islocked /*  */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from bp3app_info where bp3app_infoid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists bp3app_info_lock
go
create procedure bp3app_info_lock /*  */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call bp3app_info_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update bp3app_info set lockuserid =auserid ,locksessionid=null  where bp3app_infoid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update bp3app_info set lockuserid=null ,locksessionid =acursession  where bp3app_infoid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists bp3app_info_unlock
go
create procedure bp3app_info_unlock /*  */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call bp3app_info_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update bp3app_info set lockuserid =null  where bp3app_infoid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update bp3app_info set locksessionid =null  where bp3app_infoid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS bp3app_info_client_trigger
GO

create procedure bp3app_info_client_trigger  (
 acursession varchar(38),
 aBP3APP_INFOid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists bp3list_col_brief
go

create procedure bp3list_col_brief  (
 acursession varchar(38),
 abp3list_colid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if abp3list_colid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from bp3list_col where bp3list_colid=g2b(abp3list_colid);
 if  aec &gt;0 then
   set abrief=bp3list_col_brief_f(g2b(abp3list_colid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists bp3list_col_delete
go

create procedure bp3list_col_delete /*колонки журнала*/ (
 acursession varchar(38),
 abp3list_colid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3list_col where bp3list_colid=g2b(abp3list_colid);
if aec&gt;0 then
 select checkoperation( acursession ,'bp3list.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=bp3list_col' result;
    leave body;
  end if;
 call bp3list_col_logger(acursession,abp3list_colid) ; 
  delete from  bp3list_col 
  where  bp3list_colid = g2b(abp3list_colid) ;
  delete from num_values where ownerpartname='bp3list_col' and ownerrowid=g2b(abp3list_colid);
  end if;
    select 'ok' result;
 end 
go
GO

/*колонки журнала*/

drop procedure if exists bp3list_col_save
go

create procedure bp3list_col_save /*колонки журнала*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 abp3list_colid varchar(38)
,acolumnalignment
 integer/* выравнивание *//* выравнивание */
,agroupaggregation
 integer/* аггрегация при группировке *//* аггрегация при группировке */
,aname
 varchar (255)/* название *//* название */
,acolsort
 integer/* сортировка колонки *//* сортировка колонки */
,asequence
 integer/* последовательность *//* последовательность */
,acolwidth
 integer/* ширина колонки *//* ширина колонки */
,athestyle
 varchar (255)/* стиль *//* стиль */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3list_col where bp3list_colid=g2b(abp3list_colid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'bp3list.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=bp3list_col' result;
    leave body;
  end if;
 start transaction ; 
 call bp3list_col_logger(acursession,abp3list_colid) ; 
 update  bp3list_col set changestamp=now()
,
  columnalignment=acolumnalignment
,
  groupaggregation=agroupaggregation
,
  name=aname
,
  colsort=acolsort
,
  sequence=asequence
,
  colwidth=acolwidth
,
  thestyle=athestyle
  where  bp3list_colid = g2b(abp3list_colid) ;


call bp3list_col_client_trigger(acursession,abp3list_colid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'bp3list.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=bp3list_col' result;
    leave body;
  end if;
 start transaction;  
 insert into   bp3list_col
 (  bp3list_colid 
,instanceid
,columnalignment

,groupaggregation

,name

,colsort

,sequence

,colwidth

,thestyle

 ) values ( g2b(abp3list_colid) 
,g2b(ainstanceid)
,acolumnalignment

,agroupaggregation

,aname

,acolsort

,asequence

,acolwidth

,athestyle

 ) ;


call bp3list_col_client_trigger(acursession,abp3list_colid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists bp3list_colsrc_brief
go

create procedure bp3list_colsrc_brief  (
 acursession varchar(38),
 abp3list_colsrcid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if abp3list_colsrcid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from bp3list_colsrc where bp3list_colsrcid=g2b(abp3list_colsrcid);
 if  aec &gt;0 then
   set abrief=bp3list_colsrc_brief_f(g2b(abp3list_colsrcid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists bp3list_colsrc_delete
go

create procedure bp3list_colsrc_delete /*состав колонки*/ (
 acursession varchar(38),
 abp3list_colsrcid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3list_colsrc where bp3list_colsrcid=g2b(abp3list_colsrcid);
if aec&gt;0 then
 select checkoperation( acursession ,'bp3list.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=bp3list_colsrc' result;
    leave body;
  end if;
 call bp3list_colsrc_logger(acursession,abp3list_colsrcid) ; 
  delete from  bp3list_colsrc 
  where  bp3list_colsrcid = g2b(abp3list_colsrcid) ;
  delete from num_values where ownerpartname='bp3list_colsrc' and ownerrowid=g2b(abp3list_colsrcid);
  end if;
    select 'ok' result;
 end 
go
GO

/*состав колонки*/

drop procedure if exists bp3list_colsrc_save
go

create procedure bp3list_colsrc_save /*состав колонки*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 abp3list_colsrcid varchar(38)
,aviewfield
 varchar (255)/* поле представления *//* поле представления */
,asrcpartview varchar(38)/* представление *//* представление */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3list_colsrc where bp3list_colsrcid=g2b(abp3list_colsrcid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'bp3list.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=bp3list_colsrc' result;
    leave body;
  end if;
 start transaction ; 
 call bp3list_colsrc_logger(acursession,abp3list_colsrcid) ; 
 update  bp3list_colsrc set changestamp=now()
,
  viewfield=aviewfield
,
  srcpartview=g2b(asrcpartview)
  where  bp3list_colsrcid = g2b(abp3list_colsrcid) ;


call bp3list_colsrc_client_trigger(acursession,abp3list_colsrcid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'bp3list.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=bp3list_colsrc' result;
    leave body;
  end if;
 start transaction;  
 insert into   bp3list_colsrc
 (  bp3list_colsrcid 
,parentstructrowid
,viewfield

,srcpartview

 ) values ( g2b(abp3list_colsrcid) 
,g2b(aparentstructrowid)
,aviewfield

,g2b(asrcpartview)

 ) ;


call bp3list_colsrc_client_trigger(acursession,abp3list_colsrcid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists bp3list_colsrc_copy
go

create procedure bp3list_colsrc_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into bp3list_colsrc 
 ( bp3list_colsrcid 
,parentstructrowid
,viewfield

,srcpartview

 ) select 
copymap(acopyaction,b2g(bp3list_colsrcid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,viewfield

,srcpartview

 from bp3list_colsrc
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists bp3list_col_copy
go

create procedure bp3list_col_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
declare aid binary(16);
declare fetch_done int default false;
declare copy_cursor_bp3list_col cursor for
select bp3list_colid from bp3list_col where 
instanceid =ainstanceid;
 declare continue handler for not found set fetch_done = true;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into bp3list_col 
 ( bp3list_colid 
,instanceid
,columnalignment

,groupaggregation

,name

,colsort

,sequence

,colwidth

,thestyle

 ) select 
copymap(acopyaction,b2g(bp3list_colid)) 
,copymap(acopyaction,b2g(instanceid))
,columnalignment

,groupaggregation

,name

,colsort

,sequence

,colwidth

,thestyle

 from bp3list_col
 where instanceid =g2b( ainstanceid); 
open copy_cursor_bp3list_col;
  set  fetch_done=false;
fetch copy_cursor_bp3list_col into aid;
while not fetch_done do 
    call bp3list_colsrc_copy(acursession,acopyaction,ainstanceid,aid);
  set  fetch_done=false;
    fetch copy_cursor_bp3list_col into aid;
end while;

close copy_cursor_bp3list_col;
 end 
go
GO


drop procedure if exists bp3list_col_logger
go

create procedure bp3list_col_logger /*колонки журнала*/ (
 acursession varchar(38),
 abp3list_colid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists bp3list_colsrc_logger
go

create procedure bp3list_colsrc_logger /*состав колонки*/ (
 acursession varchar(38),
 abp3list_colsrcid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists bp3list_col_parent
go
create procedure bp3list_col_parent /* колонки журнала*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from bp3list_col where  bp3list_colid=arowid;
 end 
go
GO


drop procedure if exists bp3list_col_islocked
go
create procedure bp3list_col_islocked /* колонки журнала */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from bp3list_col where bp3list_colid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists bp3list_col_lock
go
create procedure bp3list_col_lock /* колонки журнала */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call bp3list_col_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update bp3list_col set lockuserid =auserid ,locksessionid=null  where bp3list_colid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update bp3list_col set lockuserid=null ,locksessionid =acursession  where bp3list_colid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists bp3list_col_unlock
go
create procedure bp3list_col_unlock /* колонки журнала */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call bp3list_col_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update bp3list_col set lockuserid =null  where bp3list_colid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update bp3list_col set locksessionid =null  where bp3list_colid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS bp3list_col_client_trigger
GO

create procedure bp3list_col_client_trigger  (
 acursession varchar(38),
 abp3list_colid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists bp3list_colsrc_parent
go
create procedure bp3list_colsrc_parent /* состав колонки*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from bp3list_colsrc where  bp3list_colsrcid=arowid;
  set aparenttable = 'bp3list_col';
 end 
go
GO


drop procedure if exists bp3list_colsrc_islocked
go
create procedure bp3list_colsrc_islocked /* состав колонки */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from bp3list_colsrc where bp3list_colsrcid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists bp3list_colsrc_lock
go
create procedure bp3list_colsrc_lock /* состав колонки */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call bp3list_colsrc_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update bp3list_colsrc set lockuserid =auserid ,locksessionid=null  where bp3list_colsrcid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update bp3list_colsrc set lockuserid=null ,locksessionid =acursession  where bp3list_colsrcid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists bp3list_colsrc_unlock
go
create procedure bp3list_colsrc_unlock /* состав колонки */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call bp3list_colsrc_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update bp3list_colsrc set lockuserid =null  where bp3list_colsrcid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update bp3list_colsrc set locksessionid =null  where bp3list_colsrcid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS bp3list_colsrc_client_trigger
GO

create procedure bp3list_colsrc_client_trigger  (
 acursession varchar(38),
 abp3list_colsrcid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists bp3list_def_brief
go

create procedure bp3list_def_brief  (
 acursession varchar(38),
 abp3list_defid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if abp3list_defid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from bp3list_def where bp3list_defid=g2b(abp3list_defid);
 if  aec &gt;0 then
   set abrief=bp3list_def_brief_f(g2b(abp3list_defid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists bp3list_def_delete
go

create procedure bp3list_def_delete /*журнал*/ (
 acursession varchar(38),
 abp3list_defid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3list_def where bp3list_defid=g2b(abp3list_defid);
if aec&gt;0 then
 select checkoperation( acursession ,'bp3list.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=bp3list_def' result;
    leave body;
  end if;
 call bp3list_def_logger(acursession,abp3list_defid) ; 
  delete from  bp3list_def 
  where  bp3list_defid = g2b(abp3list_defid) ;
  delete from num_values where ownerpartname='bp3list_def' and ownerrowid=g2b(abp3list_defid);
  end if;
    select 'ok' result;
 end 
go
GO

/*журнал*/

drop procedure if exists bp3list_def_save
go

create procedure bp3list_def_save /*журнал*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 abp3list_defid varchar(38)
,aname
 varchar (255)/* название *//* название */
,athecomment
 text/* описание *//* описание */
,asourceview varchar(38)/* запрос *//* запрос */
,aonrun
 integer/* при открытии *//* при открытии */
,aeditcard varchar(38)/* карточка для редактирования *//* карточка для редактирования */
,anewcard varchar(38)/* карточка для создания *//* карточка для создания */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3list_def where bp3list_defid=g2b(abp3list_defid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'bp3list.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=bp3list_def' result;
    leave body;
  end if;
 start transaction ; 
 call bp3list_def_logger(acursession,abp3list_defid) ; 
 update  bp3list_def set changestamp=now()
,
  name=aname
,
  thecomment=athecomment
,
  sourceview=g2b(asourceview)
,
  onrun=aonrun
,
  editcard=g2b(aeditcard)
,
  newcard=g2b(anewcard)
  where  bp3list_defid = g2b(abp3list_defid) ;


call bp3list_def_client_trigger(acursession,abp3list_defid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'bp3list.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=bp3list_def' result;
    leave body;
  end if;
select count(*) into aec from bp3list_def where 
instanceid=g2b(ainstanceid);
if aec &gt;0 then 
    select 'невозможно создать вторую строку в однострочной сессии. раздел: &lt;bp3list_def&gt;' result;
    rollback;
    leave body;
 end if;
 start transaction;  
 insert into   bp3list_def
 (  bp3list_defid 
,instanceid
,name

,thecomment

,sourceview

,onrun

,editcard

,newcard

 ) values ( g2b(abp3list_defid) 
,g2b(ainstanceid)
,aname

,athecomment

,g2b(asourceview)

,aonrun

,g2b(aeditcard)

,g2b(anewcard)

 ) ;


call bp3list_def_client_trigger(acursession,abp3list_defid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists bp3list_def_copy
go

create procedure bp3list_def_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into bp3list_def 
 ( bp3list_defid 
,instanceid
,name

,thecomment

,sourceview

,onrun

,editcard

,newcard

 ) select 
copymap(acopyaction,b2g(bp3list_defid)) 
,copymap(acopyaction,b2g(instanceid))
,name

,thecomment

,sourceview

,onrun

,editcard

,newcard

 from bp3list_def
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists bp3list_def_logger
go

create procedure bp3list_def_logger /*журнал*/ (
 acursession varchar(38),
 abp3list_defid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists bp3list_def_parent
go
create procedure bp3list_def_parent /* журнал*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from bp3list_def where  bp3list_defid=arowid;
 end 
go
GO


drop procedure if exists bp3list_def_islocked
go
create procedure bp3list_def_islocked /* журнал */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from bp3list_def where bp3list_defid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists bp3list_def_lock
go
create procedure bp3list_def_lock /* журнал */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call bp3list_def_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update bp3list_def set lockuserid =auserid ,locksessionid=null  where bp3list_defid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update bp3list_def set lockuserid=null ,locksessionid =acursession  where bp3list_defid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists bp3list_def_unlock
go
create procedure bp3list_def_unlock /* журнал */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call bp3list_def_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update bp3list_def set lockuserid =null  where bp3list_defid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update bp3list_def set locksessionid =null  where bp3list_defid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS bp3list_def_client_trigger
GO

create procedure bp3list_def_client_trigger  (
 acursession varchar(38),
 abp3list_defid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists bp3list_filter_brief
go

create procedure bp3list_filter_brief  (
 acursession varchar(38),
 abp3list_filterid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if abp3list_filterid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from bp3list_filter where bp3list_filterid=g2b(abp3list_filterid);
 if  aec &gt;0 then
   set abrief=bp3list_filter_brief_f(g2b(abp3list_filterid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists bp3list_filter_delete
go

create procedure bp3list_filter_delete /*группа полей фильтра*/ (
 acursession varchar(38),
 abp3list_filterid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3list_filter where bp3list_filterid=g2b(abp3list_filterid);
if aec&gt;0 then
 select checkoperation( acursession ,'bp3list.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=bp3list_filter' result;
    leave body;
  end if;
 call bp3list_filter_logger(acursession,abp3list_filterid) ; 
  delete from  bp3list_filter 
  where  bp3list_filterid = g2b(abp3list_filterid) ;
  delete from num_values where ownerpartname='bp3list_filter' and ownerrowid=g2b(abp3list_filterid);
  end if;
    select 'ok' result;
 end 
go
GO

/*группа полей фильтра*/

drop procedure if exists bp3list_filter_save
go

create procedure bp3list_filter_save /*группа полей фильтра*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 abp3list_filterid varchar(38)
,acaption
 varchar (255)/* заголовок *//* заголовок */
,asequence
 integer/* последовательность *//* последовательность */
,aname
 varchar (64)/* название *//* название */
,aallowignore
 integer/* можно отключать *//* можно отключать */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3list_filter where bp3list_filterid=g2b(abp3list_filterid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'bp3list.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=bp3list_filter' result;
    leave body;
  end if;
 start transaction ; 
 call bp3list_filter_logger(acursession,abp3list_filterid) ; 
 update  bp3list_filter set changestamp=now()
,
  caption=acaption
,
  sequence=asequence
,
  name=aname
,
  allowignore=aallowignore
  where  bp3list_filterid = g2b(abp3list_filterid) ;


call bp3list_filter_client_trigger(acursession,abp3list_filterid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'bp3list.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=bp3list_filter' result;
    leave body;
  end if;
 start transaction;  
 insert into   bp3list_filter
 (  bp3list_filterid 
,instanceid
,caption

,sequence

,name

,allowignore

 ) values ( g2b(abp3list_filterid) 
,g2b(ainstanceid)
,acaption

,asequence

,aname

,aallowignore

 ) ;


call bp3list_filter_client_trigger(acursession,abp3list_filterid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists bp3list_filterfield_brief
go

create procedure bp3list_filterfield_brief  (
 acursession varchar(38),
 abp3list_filterfieldid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if abp3list_filterfieldid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from bp3list_filterfield where bp3list_filterfieldid=g2b(abp3list_filterfieldid);
 if  aec &gt;0 then
   set abrief=bp3list_filterfield_brief_f(g2b(abp3list_filterfieldid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists bp3list_filterfield_delete
go

create procedure bp3list_filterfield_delete /*поле фильтра*/ (
 acursession varchar(38),
 abp3list_filterfieldid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3list_filterfield where bp3list_filterfieldid=g2b(abp3list_filterfieldid);
if aec&gt;0 then
 select checkoperation( acursession ,'bp3list.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=bp3list_filterfield' result;
    leave body;
  end if;
 call bp3list_filterfield_logger(acursession,abp3list_filterfieldid) ; 
  delete from  bp3list_filterfield 
  where  bp3list_filterfieldid = g2b(abp3list_filterfieldid) ;
  delete from num_values where ownerpartname='bp3list_filterfield' and ownerrowid=g2b(abp3list_filterfieldid);
  end if;
    select 'ok' result;
 end 
go
GO

/*поле фильтра*/

drop procedure if exists bp3list_filterfield_save
go

create procedure bp3list_filterfield_save /*поле фильтра*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 abp3list_filterfieldid varchar(38)
,afieldsize
 integer/* размер *//* размер */
,areftype
 integer/* тип ссылки *//* тип ссылки */
,acaption
 varchar (255)/* заголовок *//* заголовок */
,aname
 varchar (255)/* название *//* название */
,afieldtype varchar(38)/* тип поля *//* тип поля */
,avaluearray
 integer/* массив значений *//* массив значений */
,asequence
 integer/* последовательность *//* последовательность */
,areftopart varchar(38)/* раздел, куда ссылаемся *//* раздел, куда ссылаемся */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3list_filterfield where bp3list_filterfieldid=g2b(abp3list_filterfieldid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'bp3list.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=bp3list_filterfield' result;
    leave body;
  end if;
 start transaction ; 
 call bp3list_filterfield_logger(acursession,abp3list_filterfieldid) ; 
 update  bp3list_filterfield set changestamp=now()
,
  fieldsize=afieldsize
,
  reftype=areftype
,
  caption=acaption
,
  name=aname
,
  fieldtype=g2b(afieldtype)
,
  valuearray=avaluearray
,
  sequence=asequence
,
  reftopart=g2b(areftopart)
  where  bp3list_filterfieldid = g2b(abp3list_filterfieldid) ;


call bp3list_filterfield_client_trigger(acursession,abp3list_filterfieldid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'bp3list.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=bp3list_filterfield' result;
    leave body;
  end if;
 start transaction;  
 insert into   bp3list_filterfield
 (  bp3list_filterfieldid 
,parentstructrowid
,fieldsize

,reftype

,caption

,name

,fieldtype

,valuearray

,sequence

,reftopart

 ) values ( g2b(abp3list_filterfieldid) 
,g2b(aparentstructrowid)
,afieldsize

,areftype

,acaption

,aname

,g2b(afieldtype)

,avaluearray

,asequence

,g2b(areftopart)

 ) ;


call bp3list_filterfield_client_trigger(acursession,abp3list_filterfieldid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists bp3list_filterfield_copy
go

create procedure bp3list_filterfield_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into bp3list_filterfield 
 ( bp3list_filterfieldid 
,parentstructrowid
,fieldsize

,reftype

,caption

,name

,fieldtype

,valuearray

,sequence

,reftopart

 ) select 
copymap(acopyaction,b2g(bp3list_filterfieldid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,fieldsize

,reftype

,caption

,name

,fieldtype

,valuearray

,sequence

,reftopart

 from bp3list_filterfield
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists bp3list_filter_copy
go

create procedure bp3list_filter_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
declare aid binary(16);
declare fetch_done int default false;
declare copy_cursor_bp3list_filter cursor for
select bp3list_filterid from bp3list_filter where 
instanceid =ainstanceid;
 declare continue handler for not found set fetch_done = true;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into bp3list_filter 
 ( bp3list_filterid 
,instanceid
,caption

,sequence

,name

,allowignore

 ) select 
copymap(acopyaction,b2g(bp3list_filterid)) 
,copymap(acopyaction,b2g(instanceid))
,caption

,sequence

,name

,allowignore

 from bp3list_filter
 where instanceid =g2b( ainstanceid); 
open copy_cursor_bp3list_filter;
  set  fetch_done=false;
fetch copy_cursor_bp3list_filter into aid;
while not fetch_done do 
    call bp3list_filterfield_copy(acursession,acopyaction,ainstanceid,aid);
  set  fetch_done=false;
    fetch copy_cursor_bp3list_filter into aid;
end while;

close copy_cursor_bp3list_filter;
 end 
go
GO


drop procedure if exists bp3list_filter_logger
go

create procedure bp3list_filter_logger /*группа полей фильтра*/ (
 acursession varchar(38),
 abp3list_filterid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists bp3list_filterfield_logger
go

create procedure bp3list_filterfield_logger /*поле фильтра*/ (
 acursession varchar(38),
 abp3list_filterfieldid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists bp3list_filter_parent
go
create procedure bp3list_filter_parent /* группа полей фильтра*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from bp3list_filter where  bp3list_filterid=arowid;
 end 
go
GO


drop procedure if exists bp3list_filter_islocked
go
create procedure bp3list_filter_islocked /* группа полей фильтра */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from bp3list_filter where bp3list_filterid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists bp3list_filter_lock
go
create procedure bp3list_filter_lock /* группа полей фильтра */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call bp3list_filter_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update bp3list_filter set lockuserid =auserid ,locksessionid=null  where bp3list_filterid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update bp3list_filter set lockuserid=null ,locksessionid =acursession  where bp3list_filterid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists bp3list_filter_unlock
go
create procedure bp3list_filter_unlock /* группа полей фильтра */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call bp3list_filter_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update bp3list_filter set lockuserid =null  where bp3list_filterid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update bp3list_filter set locksessionid =null  where bp3list_filterid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS bp3list_filter_client_trigger
GO

create procedure bp3list_filter_client_trigger  (
 acursession varchar(38),
 abp3list_filterid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists bp3list_filterfield_parent
go
create procedure bp3list_filterfield_parent /* поле фильтра*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from bp3list_filterfield where  bp3list_filterfieldid=arowid;
  set aparenttable = 'bp3list_filter';
 end 
go
GO


drop procedure if exists bp3list_filterfield_islocked
go
create procedure bp3list_filterfield_islocked /* поле фильтра */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from bp3list_filterfield where bp3list_filterfieldid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists bp3list_filterfield_lock
go
create procedure bp3list_filterfield_lock /* поле фильтра */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call bp3list_filterfield_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update bp3list_filterfield set lockuserid =auserid ,locksessionid=null  where bp3list_filterfieldid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update bp3list_filterfield set lockuserid=null ,locksessionid =acursession  where bp3list_filterfieldid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists bp3list_filterfield_unlock
go
create procedure bp3list_filterfield_unlock /* поле фильтра */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call bp3list_filterfield_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update bp3list_filterfield set lockuserid =null  where bp3list_filterfieldid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update bp3list_filterfield set locksessionid =null  where bp3list_filterfieldid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS bp3list_filterfield_client_trigger
GO

create procedure bp3list_filterfield_client_trigger  (
 acursession varchar(38),
 abp3list_filterfieldid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists the_session_brief
go

create procedure the_session_brief  (
 acursession varchar(38),
 athe_sessionid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if athe_sessionid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from the_session where the_sessionid=g2b(athe_sessionid);
 if  aec &gt;0 then
   set abrief=the_session_brief_f(g2b(athe_sessionid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists the_session_delete
go

create procedure the_session_delete /*зарегистрированные сессии пользователей*/ (
 acursession varchar(38),
 athe_sessionid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from the_session where the_sessionid=g2b(athe_sessionid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzsystem.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=the_session' result;
    leave body;
  end if;
 call the_session_logger(acursession,athe_sessionid) ; 
  delete from  the_session 
  where  the_sessionid = g2b(athe_sessionid) ;
  delete from num_values where ownerpartname='the_session' and ownerrowid=g2b(athe_sessionid);
  end if;
    select 'ok' result;
 end 
go
GO

/*сессия пользователя*/

drop procedure if exists the_session_save
go

create procedure the_session_save /*зарегистрированные сессии пользователей*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 athe_sessionid varchar(38)
,aapplicationid varchar(38)/* приложение *//* приложение */
,auserrole varchar(38)/* текущая роль пользователя *//* текущая роль пользователя */
,aclosedat
 datetime/* момент закрытия *//* момент закрытия */
,aclosed
 integer/* закрыта *//* закрыта */
,ausersid varchar(38)/* пользователь *//* пользователь */
,alastaccess
 datetime/* последнее подтверждение *//* последнее подтверждение */
,astartat
 datetime/* момент открытия *//* момент открытия */
,alang
 varchar (25)/* локализация *//* локализация */
,alogin
 varchar (255)/* login *//* login */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from the_session where the_sessionid=g2b(athe_sessionid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzsystem.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=the_session' result;
    leave body;
  end if;
 start transaction ; 
 call the_session_logger(acursession,athe_sessionid) ; 
 update  the_session set changestamp=now()
,
  applicationid=g2b(aapplicationid)
,
  userrole=g2b(auserrole)
,
  closedat=aclosedat
,
  closed=aclosed
,
  usersid=g2b(ausersid)
,
  lastaccess=alastaccess
,
  startat=astartat
,
  lang=alang
,
  login=alogin
  where  the_sessionid = g2b(athe_sessionid) ;


call the_session_client_trigger(acursession,athe_sessionid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzsystem.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=the_session' result;
    leave body;
  end if;
 start transaction;  
 insert into   the_session
 (  the_sessionid 
,instanceid
,applicationid

,userrole

,closedat

,closed

,usersid

,lastaccess

,startat

,lang

,login

 ) values ( g2b(athe_sessionid) 
,g2b(ainstanceid)
,g2b(aapplicationid)

,g2b(auserrole)

,aclosedat

,aclosed

,g2b(ausersid)

,alastaccess

,astartat

,alang

,alogin

 ) ;


call the_session_client_trigger(acursession,athe_sessionid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists the_session_copy
go

create procedure the_session_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into the_session 
 ( the_sessionid 
,instanceid
,applicationid

,userrole

,closedat

,closed

,usersid

,lastaccess

,startat

,lang

,login

 ) select 
copymap(acopyaction,b2g(the_sessionid)) 
,copymap(acopyaction,b2g(instanceid))
,applicationid

,userrole

,closedat

,closed

,usersid

,lastaccess

,startat

,lang

,login

 from the_session
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists the_session_logger
go

create procedure the_session_logger /*зарегистрированные сессии пользователей*/ (
 acursession varchar(38),
 athe_sessionid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists the_session_parent
go
create procedure the_session_parent /* зарегистрированные сессии пользователей*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from the_session where  the_sessionid=arowid;
 end 
go
GO


drop procedure if exists the_session_islocked
go
create procedure the_session_islocked /* зарегистрированные сессии пользователей */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from the_session where the_sessionid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists the_session_lock
go
create procedure the_session_lock /* зарегистрированные сессии пользователей */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call the_session_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update the_session set lockuserid =auserid ,locksessionid=null  where the_sessionid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update the_session set lockuserid=null ,locksessionid =acursession  where the_sessionid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists the_session_unlock
go
create procedure the_session_unlock /* зарегистрированные сессии пользователей */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call the_session_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update the_session set lockuserid =null  where the_sessionid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update the_session set locksessionid =null  where the_sessionid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS the_session_client_trigger
GO

create procedure the_session_client_trigger  (
 acursession varchar(38),
 athe_Sessionid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists sysrefcache_brief
go

create procedure sysrefcache_brief  (
 acursession varchar(38),
 asysrefcacheid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if asysrefcacheid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from sysrefcache where sysrefcacheid=g2b(asysrefcacheid);
 if  aec &gt;0 then
   set abrief=sysrefcache_brief_f(g2b(asysrefcacheid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists sysrefcache_delete
go

create procedure sysrefcache_delete /*владельцы информации для к объектам которых
разрешен достуа для  текущей сесии*/ (
 acursession varchar(38),
 asysrefcacheid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from sysrefcache where sysrefcacheid=g2b(asysrefcacheid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzsystem.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=sysrefcache' result;
    leave body;
  end if;
 call sysrefcache_logger(acursession,asysrefcacheid) ; 
  delete from  sysrefcache 
  where  sysrefcacheid = g2b(asysrefcacheid) ;
  delete from num_values where ownerpartname='sysrefcache' and ownerrowid=g2b(asysrefcacheid);
  end if;
    select 'ok' result;
 end 
go
GO

/*разрешенные владельцы*/

drop procedure if exists sysrefcache_save
go

create procedure sysrefcache_save /*владельцы информации для к объектам которых
разрешен достуа для  текущей сесии*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 asysrefcacheid varchar(38)
,acachetype
 integer/* тип кеширования *//* тип кеширования */
,aobjectownerid binary(16)/* идентификатор владельца *//* идентификатор владельца */
,asessionid varchar(38)/* сессия *//* сессия */
,athemarket
 integer/* рынок *//* рынок */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from sysrefcache where sysrefcacheid=g2b(asysrefcacheid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzsystem.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=sysrefcache' result;
    leave body;
  end if;
 start transaction ; 
 call sysrefcache_logger(acursession,asysrefcacheid) ; 
 update  sysrefcache set changestamp=now()
,
  cachetype=acachetype
,
  objectownerid=aobjectownerid
,
  sessionid=g2b(asessionid)
,
  themarket=athemarket
  where  sysrefcacheid = g2b(asysrefcacheid) ;


call sysrefcache_client_trigger(acursession,asysrefcacheid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzsystem.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=sysrefcache' result;
    leave body;
  end if;
 start transaction;  
 insert into   sysrefcache
 (  sysrefcacheid 
,instanceid
,cachetype

,objectownerid

,sessionid

,themarket

 ) values ( g2b(asysrefcacheid) 
,g2b(ainstanceid)
,acachetype

,aobjectownerid

,g2b(asessionid)

,athemarket

 ) ;


call sysrefcache_client_trigger(acursession,asysrefcacheid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists sysrefcache_copy
go

create procedure sysrefcache_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into sysrefcache 
 ( sysrefcacheid 
,instanceid
,cachetype

,objectownerid

,sessionid

,themarket

 ) select 
copymap(acopyaction,b2g(sysrefcacheid)) 
,copymap(acopyaction,b2g(instanceid))
,cachetype

,objectownerid

,sessionid

,themarket

 from sysrefcache
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists sysrefcache_logger
go

create procedure sysrefcache_logger /*владельцы информации для к объектам которых
разрешен достуа для  текущей сесии*/ (
 acursession varchar(38),
 asysrefcacheid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists sysrefcache_parent
go
create procedure sysrefcache_parent /* владельцы информации для к объектам которых
разрешен достуа для  текущей сесии*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from sysrefcache where  sysrefcacheid=arowid;
 end 
go
GO


drop procedure if exists sysrefcache_islocked
go
create procedure sysrefcache_islocked /* владельцы информации для к объектам которых
разрешен достуа для  текущей сесии */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from sysrefcache where sysrefcacheid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists sysrefcache_lock
go
create procedure sysrefcache_lock /* владельцы информации для к объектам которых
разрешен достуа для  текущей сесии */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call sysrefcache_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update sysrefcache set lockuserid =auserid ,locksessionid=null  where sysrefcacheid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update sysrefcache set lockuserid=null ,locksessionid =acursession  where sysrefcacheid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists sysrefcache_unlock
go
create procedure sysrefcache_unlock /* владельцы информации для к объектам которых
разрешен достуа для  текущей сесии */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call sysrefcache_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update sysrefcache set lockuserid =null  where sysrefcacheid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update sysrefcache set locksessionid =null  where sysrefcacheid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS sysrefcache_client_trigger
GO

create procedure sysrefcache_client_trigger  (
 acursession varchar(38),
 aSysRefCacheid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists syslog_brief
go

create procedure syslog_brief  (
 acursession varchar(38),
 asyslogid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if asyslogid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from syslog where syslogid=g2b(asyslogid);
 if  aec &gt;0 then
   set abrief=syslog_brief_f(g2b(asyslogid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists syslog_delete
go

create procedure syslog_delete /*журнал событий, которые произошли в системе*/ (
 acursession varchar(38),
 asyslogid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from syslog where syslogid=g2b(asyslogid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzsystem.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=syslog' result;
    leave body;
  end if;
 call syslog_logger(acursession,asyslogid) ; 
  delete from  syslog 
  where  syslogid = g2b(asyslogid) ;
  delete from num_values where ownerpartname='syslog' and ownerrowid=g2b(asyslogid);
  end if;
    select 'ok' result;
 end 
go
GO

/*журнал событий*/

drop procedure if exists syslog_save
go

create procedure syslog_save /*журнал событий, которые произошли в системе*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 asyslogid varchar(38)
,athesession varchar(38)/* сессия *//* сессия */
,athe_resource
 varchar (255)/* ресурс *//* ресурс */
,alogstructid
 varchar (255)/* раздел с которым происхоит действие *//* раздел с которым происхоит действие */
,averb
 varchar (80)/* действие *//* действие */
,aloginstanceid binary(16)/* идентификатор документа *//* идентификатор документа */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from syslog where syslogid=g2b(asyslogid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzsystem.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=syslog' result;
    leave body;
  end if;
 start transaction ; 
 call syslog_logger(acursession,asyslogid) ; 
 update  syslog set changestamp=now()
,
  thesession=g2b(athesession)
,
  the_resource=athe_resource
,
  logstructid=alogstructid
,
  verb=averb
,
  loginstanceid=aloginstanceid
  where  syslogid = g2b(asyslogid) ;


call syslog_client_trigger(acursession,asyslogid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzsystem.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=syslog' result;
    leave body;
  end if;
 start transaction;  
 insert into   syslog
 (  syslogid 
,instanceid
,thesession

,the_resource

,logstructid

,verb

,loginstanceid

 ) values ( g2b(asyslogid) 
,g2b(ainstanceid)
,g2b(athesession)

,athe_resource

,alogstructid

,averb

,aloginstanceid

 ) ;


call syslog_client_trigger(acursession,asyslogid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists syslog_copy
go

create procedure syslog_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into syslog 
 ( syslogid 
,instanceid
,thesession

,the_resource

,logstructid

,verb

,loginstanceid

 ) select 
copymap(acopyaction,b2g(syslogid)) 
,copymap(acopyaction,b2g(instanceid))
,thesession

,the_resource

,logstructid

,verb

,loginstanceid

 from syslog
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists syslog_logger
go

create procedure syslog_logger /*журнал событий, которые произошли в системе*/ (
 acursession varchar(38),
 asyslogid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists syslog_parent
go
create procedure syslog_parent /* журнал событий, которые произошли в системе*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from syslog where  syslogid=arowid;
 end 
go
GO


drop procedure if exists syslog_islocked
go
create procedure syslog_islocked /* журнал событий, которые произошли в системе */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from syslog where syslogid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists syslog_lock
go
create procedure syslog_lock /* журнал событий, которые произошли в системе */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call syslog_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update syslog set lockuserid =auserid ,locksessionid=null  where syslogid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update syslog set lockuserid=null ,locksessionid =acursession  where syslogid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists syslog_unlock
go
create procedure syslog_unlock /* журнал событий, которые произошли в системе */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call syslog_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update syslog set lockuserid =null  where syslogid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update syslog set locksessionid =null  where syslogid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS syslog_client_trigger
GO

create procedure syslog_client_trigger  (
 acursession varchar(38),
 aSysLogid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists bp3qry_column_brief
go

create procedure bp3qry_column_brief  (
 acursession varchar(38),
 abp3qry_columnid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if abp3qry_columnid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from bp3qry_column where bp3qry_columnid=g2b(abp3qry_columnid);
 if  aec &gt;0 then
   set abrief=bp3qry_column_brief_f(g2b(abp3qry_columnid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists bp3qry_column_delete
go

create procedure bp3qry_column_delete /*колонка пердставления*/ (
 acursession varchar(38),
 abp3qry_columnid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3qry_column where bp3qry_columnid=g2b(abp3qry_columnid);
if aec&gt;0 then
 select checkoperation( acursession ,'bp3qry.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=bp3qry_column' result;
    leave body;
  end if;
 call bp3qry_column_logger(acursession,abp3qry_columnid) ; 
  delete from  bp3qry_column 
  where  bp3qry_columnid = g2b(abp3qry_columnid) ;
  delete from num_values where ownerpartname='bp3qry_column' and ownerrowid=g2b(abp3qry_columnid);
  end if;
    select 'ok' result;
 end 
go
GO

/*колонка*/

drop procedure if exists bp3qry_column_save
go

create procedure bp3qry_column_save /*колонка пердставления*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 abp3qry_columnid varchar(38)
,aforcombo
 integer/* для комбо *//* для комбо */
,afrompart varchar(38)/* раздел *//* раздел */
,aaggregation
 integer/* агрегация *//* агрегация */
,asequence
 integer/* № *//* № */
,athe_alias
 varchar (64)/* псвдоним *//* псвдоним */
,aname
 varchar (255)/* название *//* название */
,afield varchar(38)/* поле *//* поле */
,aexpression
 text/* формула *//* формула */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3qry_column where bp3qry_columnid=g2b(abp3qry_columnid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'bp3qry.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=bp3qry_column' result;
    leave body;
  end if;
 start transaction ; 
 call bp3qry_column_logger(acursession,abp3qry_columnid) ; 
 update  bp3qry_column set changestamp=now()
,
  forcombo=aforcombo
,
  frompart=g2b(afrompart)
,
  aggregation=aaggregation
,
  sequence=asequence
,
  the_alias=athe_alias
,
  name=aname
,
  field=g2b(afield)
,
  expression=aexpression
  where  bp3qry_columnid = g2b(abp3qry_columnid) ;


call bp3qry_column_client_trigger(acursession,abp3qry_columnid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'bp3qry.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=bp3qry_column' result;
    leave body;
  end if;
 start transaction;  
 insert into   bp3qry_column
 (  bp3qry_columnid 
,instanceid
,forcombo

,frompart

,aggregation

,sequence

,the_alias

,name

,field

,expression

 ) values ( g2b(abp3qry_columnid) 
,g2b(ainstanceid)
,aforcombo

,g2b(afrompart)

,aaggregation

,asequence

,athe_alias

,aname

,g2b(afield)

,aexpression

 ) ;


call bp3qry_column_client_trigger(acursession,abp3qry_columnid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists bp3qry_column_copy
go

create procedure bp3qry_column_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into bp3qry_column 
 ( bp3qry_columnid 
,instanceid
,forcombo

,frompart

,aggregation

,sequence

,the_alias

,name

,field

,expression

 ) select 
copymap(acopyaction,b2g(bp3qry_columnid)) 
,copymap(acopyaction,b2g(instanceid))
,forcombo

,frompart

,aggregation

,sequence

,the_alias

,name

,field

,expression

 from bp3qry_column
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists bp3qry_column_logger
go

create procedure bp3qry_column_logger /*колонка пердставления*/ (
 acursession varchar(38),
 abp3qry_columnid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists bp3qry_column_parent
go
create procedure bp3qry_column_parent /* колонка пердставления*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from bp3qry_column where  bp3qry_columnid=arowid;
 end 
go
GO


drop procedure if exists bp3qry_column_islocked
go
create procedure bp3qry_column_islocked /* колонка пердставления */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from bp3qry_column where bp3qry_columnid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists bp3qry_column_lock
go
create procedure bp3qry_column_lock /* колонка пердставления */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call bp3qry_column_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update bp3qry_column set lockuserid =auserid ,locksessionid=null  where bp3qry_columnid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update bp3qry_column set lockuserid=null ,locksessionid =acursession  where bp3qry_columnid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists bp3qry_column_unlock
go
create procedure bp3qry_column_unlock /* колонка пердставления */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call bp3qry_column_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update bp3qry_column set lockuserid =null  where bp3qry_columnid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update bp3qry_column set locksessionid =null  where bp3qry_columnid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS bp3qry_column_client_trigger
GO

create procedure bp3qry_column_client_trigger  (
 acursession varchar(38),
 abp3qry_columnid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists bp3qry_def_brief
go

create procedure bp3qry_def_brief  (
 acursession varchar(38),
 abp3qry_defid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if abp3qry_defid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from bp3qry_def where bp3qry_defid=g2b(abp3qry_defid);
 if  aec &gt;0 then
   set abrief=bp3qry_def_brief_f(g2b(abp3qry_defid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists bp3qry_def_delete
go

create procedure bp3qry_def_delete /*вариант представления, который может использоваться для создания журнала*/ (
 acursession varchar(38),
 abp3qry_defid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3qry_def where bp3qry_defid=g2b(abp3qry_defid);
if aec&gt;0 then
 select checkoperation( acursession ,'bp3qry.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=bp3qry_def' result;
    leave body;
  end if;
 call bp3qry_def_logger(acursession,abp3qry_defid) ; 
  delete from  bp3qry_def 
  where  bp3qry_defid = g2b(abp3qry_defid) ;
  delete from num_values where ownerpartname='bp3qry_def' and ownerrowid=g2b(abp3qry_defid);
  end if;
    select 'ok' result;
 end 
go
GO

/*представление*/

drop procedure if exists bp3qry_def_save
go

create procedure bp3qry_def_save /*вариант представления, который может использоваться для создания журнала*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 abp3qry_defid varchar(38)
,athe_alias
 varchar (64)/* псевдоним *//* псевдоним */
,aforchoose
 integer/* для поиска *//* для поиска */
,aname
 varchar (255)/* название *//* название */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3qry_def where bp3qry_defid=g2b(abp3qry_defid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'bp3qry.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=bp3qry_def' result;
    leave body;
  end if;
 start transaction ; 
 call bp3qry_def_logger(acursession,abp3qry_defid) ; 
 update  bp3qry_def set changestamp=now()
,
  the_alias=athe_alias
,
  forchoose=aforchoose
,
  name=aname
  where  bp3qry_defid = g2b(abp3qry_defid) ;


call bp3qry_def_client_trigger(acursession,abp3qry_defid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'bp3qry.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=bp3qry_def' result;
    leave body;
  end if;
select count(*) into aec from bp3qry_def where 
instanceid=g2b(ainstanceid);
if aec &gt;0 then 
    select 'невозможно создать вторую строку в однострочной сессии. раздел: &lt;bp3qry_def&gt;' result;
    rollback;
    leave body;
 end if;
 start transaction;  
 insert into   bp3qry_def
 (  bp3qry_defid 
,instanceid
,the_alias

,forchoose

,name

 ) values ( g2b(abp3qry_defid) 
,g2b(ainstanceid)
,athe_alias

,aforchoose

,aname

 ) ;


call bp3qry_def_client_trigger(acursession,abp3qry_defid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists bp3qry_def_copy
go

create procedure bp3qry_def_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into bp3qry_def 
 ( bp3qry_defid 
,instanceid
,the_alias

,forchoose

,name

 ) select 
copymap(acopyaction,b2g(bp3qry_defid)) 
,copymap(acopyaction,b2g(instanceid))
,the_alias

,forchoose

,name

 from bp3qry_def
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists bp3qry_def_logger
go

create procedure bp3qry_def_logger /*вариант представления, который может использоваться для создания журнала*/ (
 acursession varchar(38),
 abp3qry_defid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists bp3qry_def_parent
go
create procedure bp3qry_def_parent /* вариант представления, который может использоваться для создания журнала*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from bp3qry_def where  bp3qry_defid=arowid;
 end 
go
GO


drop procedure if exists bp3qry_def_islocked
go
create procedure bp3qry_def_islocked /* вариант представления, который может использоваться для создания журнала */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from bp3qry_def where bp3qry_defid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists bp3qry_def_lock
go
create procedure bp3qry_def_lock /* вариант представления, который может использоваться для создания журнала */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call bp3qry_def_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update bp3qry_def set lockuserid =auserid ,locksessionid=null  where bp3qry_defid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update bp3qry_def set lockuserid=null ,locksessionid =acursession  where bp3qry_defid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists bp3qry_def_unlock
go
create procedure bp3qry_def_unlock /* вариант представления, который может использоваться для создания журнала */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call bp3qry_def_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update bp3qry_def set lockuserid =null  where bp3qry_defid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update bp3qry_def set locksessionid =null  where bp3qry_defid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS bp3qry_def_client_trigger
GO

create procedure bp3qry_def_client_trigger  (
 acursession varchar(38),
 abp3qry_defid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists bp3qry_link_brief
go

create procedure bp3qry_link_brief  (
 acursession varchar(38),
 abp3qry_linkid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if abp3qry_linkid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from bp3qry_link where bp3qry_linkid=g2b(abp3qry_linkid);
 if  aec &gt;0 then
   set abrief=bp3qry_link_brief_f(g2b(abp3qry_linkid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists bp3qry_link_delete
go

create procedure bp3qry_link_delete /*связанные представления*/ (
 acursession varchar(38),
 abp3qry_linkid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3qry_link where bp3qry_linkid=g2b(abp3qry_linkid);
if aec&gt;0 then
 select checkoperation( acursession ,'bp3qry.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=bp3qry_link' result;
    leave body;
  end if;
 call bp3qry_link_logger(acursession,abp3qry_linkid) ; 
  delete from  bp3qry_link 
  where  bp3qry_linkid = g2b(abp3qry_linkid) ;
  delete from num_values where ownerpartname='bp3qry_link' and ownerrowid=g2b(abp3qry_linkid);
  end if;
    select 'ok' result;
 end 
go
GO

/*связанные представления*/

drop procedure if exists bp3qry_link_save
go

create procedure bp3qry_link_save /*связанные представления*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 abp3qry_linkid varchar(38)
,athejoindestination varchar(38)/* свзяь: поле для join приемник *//* свзяь: поле для join приемник */
,ahandjoin
 varchar (255)/* ручной join *//* ручной join */
,aseq
 integer/* порядок *//* порядок */
,athejoinsource varchar(38)/* связь: поле для join источник *//* связь: поле для join источник */
,atheview varchar(38)/* представление *//* представление */
,areftype
 integer/* связывать как *//* связывать как */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3qry_link where bp3qry_linkid=g2b(abp3qry_linkid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'bp3qry.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=bp3qry_link' result;
    leave body;
  end if;
 start transaction ; 
 call bp3qry_link_logger(acursession,abp3qry_linkid) ; 
 update  bp3qry_link set changestamp=now()
,
  thejoindestination=g2b(athejoindestination)
,
  handjoin=ahandjoin
,
  seq=aseq
,
  thejoinsource=g2b(athejoinsource)
,
  theview=g2b(atheview)
,
  reftype=areftype
  where  bp3qry_linkid = g2b(abp3qry_linkid) ;


call bp3qry_link_client_trigger(acursession,abp3qry_linkid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'bp3qry.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=bp3qry_link' result;
    leave body;
  end if;
 start transaction;  
 insert into   bp3qry_link
 (  bp3qry_linkid 
,instanceid
,thejoindestination

,handjoin

,seq

,thejoinsource

,theview

,reftype

 ) values ( g2b(abp3qry_linkid) 
,g2b(ainstanceid)
,g2b(athejoindestination)

,ahandjoin

,aseq

,g2b(athejoinsource)

,g2b(atheview)

,areftype

 ) ;


call bp3qry_link_client_trigger(acursession,abp3qry_linkid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists bp3qry_link_copy
go

create procedure bp3qry_link_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into bp3qry_link 
 ( bp3qry_linkid 
,instanceid
,thejoindestination

,handjoin

,seq

,thejoinsource

,theview

,reftype

 ) select 
copymap(acopyaction,b2g(bp3qry_linkid)) 
,copymap(acopyaction,b2g(instanceid))
,thejoindestination

,handjoin

,seq

,thejoinsource

,theview

,reftype

 from bp3qry_link
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists bp3qry_link_logger
go

create procedure bp3qry_link_logger /*связанные представления*/ (
 acursession varchar(38),
 abp3qry_linkid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists bp3qry_link_parent
go
create procedure bp3qry_link_parent /* связанные представления*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from bp3qry_link where  bp3qry_linkid=arowid;
 end 
go
GO


drop procedure if exists bp3qry_link_islocked
go
create procedure bp3qry_link_islocked /* связанные представления */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from bp3qry_link where bp3qry_linkid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists bp3qry_link_lock
go
create procedure bp3qry_link_lock /* связанные представления */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call bp3qry_link_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update bp3qry_link set lockuserid =auserid ,locksessionid=null  where bp3qry_linkid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update bp3qry_link set lockuserid=null ,locksessionid =acursession  where bp3qry_linkid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists bp3qry_link_unlock
go
create procedure bp3qry_link_unlock /* связанные представления */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call bp3qry_link_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update bp3qry_link set lockuserid =null  where bp3qry_linkid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update bp3qry_link set locksessionid =null  where bp3qry_linkid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS bp3qry_link_client_trigger
GO

create procedure bp3qry_link_client_trigger  (
 acursession varchar(38),
 abp3qry_linkid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists users_brief
go

create procedure users_brief  (
 acursession varchar(38),
 ausersid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if ausersid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from users where usersid=g2b(ausersid);
 if  aec &gt;0 then
   set abrief=users_brief_f(g2b(ausersid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists users_delete
go

create procedure users_delete /*пользователи*/ (
 acursession varchar(38),
 ausersid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from users where usersid=g2b(ausersid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzusers.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=users' result;
    leave body;
  end if;
 call users_logger(acursession,ausersid) ; 
  delete from  users 
  where  usersid = g2b(ausersid) ;
  delete from num_values where ownerpartname='users' and ownerrowid=g2b(ausersid);
  end if;
    select 'ok' result;
 end 
go
GO

/*пользователи*/

drop procedure if exists users_save
go

create procedure users_save /*пользователи*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 ausersid varchar(38)
,afamily
 varchar (255)/* фамилия *//* фамилия */
,aname
 varchar (64)/* имя *//* имя */
,asurname
 varchar (255)/* отчество *//* отчество */
,alogin
 varchar (64)/* имя для входа *//* имя для входа */
,apassword varchar(80)/* пароль *//* пароль */
,adomainame
 varchar (255)/* доменное имя *//* доменное имя */
,aemail varchar(255)/* e-mail *//* e-mail */
,aphone
 varchar (20)/* телефон *//* телефон */
,alocalphone
 varchar (20)/* местный телефон *//* местный телефон */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from users where usersid=g2b(ausersid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzusers.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=users' result;
    leave body;
  end if;
 start transaction ; 
 call users_logger(acursession,ausersid) ; 
 update  users set changestamp=now()
,
  family=afamily
,
  name=aname
,
  surname=asurname
,
  login=alogin
,
  password=apassword
,
  domainame=adomainame
,
  email=aemail
,
  phone=aphone
,
  localphone=alocalphone
  where  usersid = g2b(ausersid) ;


call users_client_trigger(acursession,ausersid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzusers.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=users' result;
    leave body;
  end if;
 start transaction;  
 insert into   users
 (  usersid 
,instanceid
,family

,name

,surname

,login

,password

,domainame

,email

,phone

,localphone

 ) values ( g2b(ausersid) 
,g2b(ainstanceid)
,afamily

,aname

,asurname

,alogin

,apassword

,adomainame

,aemail

,aphone

,alocalphone

 ) ;


call users_client_trigger(acursession,ausersid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists users_copy
go

create procedure users_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into users 
 ( usersid 
,instanceid
,family

,name

,surname

,login

,password

,domainame

,email

,phone

,localphone

 ) select 
copymap(acopyaction,b2g(usersid)) 
,copymap(acopyaction,b2g(instanceid))
,family

,name

,surname

,login

,password

,domainame

,email

,phone

,localphone

 from users
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists users_logger
go

create procedure users_logger /*пользователи*/ (
 acursession varchar(38),
 ausersid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists users_parent
go
create procedure users_parent /* пользователи*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from users where  usersid=arowid;
 end 
go
GO


drop procedure if exists users_islocked
go
create procedure users_islocked /* пользователи */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from users where usersid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists users_lock
go
create procedure users_lock /* пользователи */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call users_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update users set lockuserid =auserid ,locksessionid=null  where usersid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update users set lockuserid=null ,locksessionid =acursession  where usersid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists users_unlock
go
create procedure users_unlock /* пользователи */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call users_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update users set lockuserid =null  where usersid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update users set locksessionid =null  where usersid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS users_client_trigger
GO

create procedure users_client_trigger  (
 acursession varchar(38),
 aUsersid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists groups_brief
go

create procedure groups_brief  (
 acursession varchar(38),
 agroupsid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if agroupsid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from groups where groupsid=g2b(agroupsid);
 if  aec &gt;0 then
   set abrief=groups_brief_f(g2b(agroupsid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists groups_delete
go

create procedure groups_delete /*группы*/ (
 acursession varchar(38),
 agroupsid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from groups where groupsid=g2b(agroupsid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzusers.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=groups' result;
    leave body;
  end if;
 call groups_logger(acursession,agroupsid) ; 
  delete from  groups 
  where  groupsid = g2b(agroupsid) ;
  delete from num_values where ownerpartname='groups' and ownerrowid=g2b(agroupsid);
  end if;
    select 'ok' result;
 end 
go
GO

/*группы*/

drop procedure if exists groups_save
go

create procedure groups_save /*группы*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 agroupsid varchar(38)
,aname
 varchar (80)/* название *//* название */
,aadgroup
 varchar (255)/* группа ad *//* группа ad */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from groups where groupsid=g2b(agroupsid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzusers.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=groups' result;
    leave body;
  end if;
 start transaction ; 
 call groups_logger(acursession,agroupsid) ; 
 update  groups set changestamp=now()
,
  name=aname
,
  adgroup=aadgroup
  where  groupsid = g2b(agroupsid) ;


call groups_client_trigger(acursession,agroupsid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzusers.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=groups' result;
    leave body;
  end if;
 start transaction;  
 insert into   groups
 (  groupsid 
,instanceid
,name

,adgroup

 ) values ( g2b(agroupsid) 
,g2b(ainstanceid)
,aname

,aadgroup

 ) ;


call groups_client_trigger(acursession,agroupsid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists groupuser_brief
go

create procedure groupuser_brief  (
 acursession varchar(38),
 agroupuserid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if agroupuserid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from groupuser where groupuserid=g2b(agroupuserid);
 if  aec &gt;0 then
   set abrief=groupuser_brief_f(g2b(agroupuserid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists groupuser_delete
go

create procedure groupuser_delete /*состав группы*/ (
 acursession varchar(38),
 agroupuserid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from groupuser where groupuserid=g2b(agroupuserid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzusers.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=groupuser' result;
    leave body;
  end if;
 call groupuser_logger(acursession,agroupuserid) ; 
  delete from  groupuser 
  where  groupuserid = g2b(agroupuserid) ;
  delete from num_values where ownerpartname='groupuser' and ownerrowid=g2b(agroupuserid);
  end if;
    select 'ok' result;
 end 
go
GO

/*состав группы*/

drop procedure if exists groupuser_save
go

create procedure groupuser_save /*состав группы*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 agroupuserid varchar(38)
,atheuser varchar(38)/* пользователь *//* пользователь */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from groupuser where groupuserid=g2b(agroupuserid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzusers.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=groupuser' result;
    leave body;
  end if;
 start transaction ; 
 call groupuser_logger(acursession,agroupuserid) ; 
 update  groupuser set changestamp=now()
,
  theuser=g2b(atheuser)
  where  groupuserid = g2b(agroupuserid) ;


call groupuser_client_trigger(acursession,agroupuserid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzusers.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=groupuser' result;
    leave body;
  end if;
 start transaction;  
 insert into   groupuser
 (  groupuserid 
,parentstructrowid
,theuser

 ) values ( g2b(agroupuserid) 
,g2b(aparentstructrowid)
,g2b(atheuser)

 ) ;


call groupuser_client_trigger(acursession,agroupuserid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists groupuser_copy
go

create procedure groupuser_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into groupuser 
 ( groupuserid 
,parentstructrowid
,theuser

 ) select 
copymap(acopyaction,b2g(groupuserid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,theuser

 from groupuser
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists groups_copy
go

create procedure groups_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
declare aid binary(16);
declare fetch_done int default false;
declare copy_cursor_groups cursor for
select groupsid from groups where 
instanceid =ainstanceid;
 declare continue handler for not found set fetch_done = true;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into groups 
 ( groupsid 
,instanceid
,name

,adgroup

 ) select 
copymap(acopyaction,b2g(groupsid)) 
,copymap(acopyaction,b2g(instanceid))
,name

,adgroup

 from groups
 where instanceid =g2b( ainstanceid); 
open copy_cursor_groups;
  set  fetch_done=false;
fetch copy_cursor_groups into aid;
while not fetch_done do 
    call groupuser_copy(acursession,acopyaction,ainstanceid,aid);
  set  fetch_done=false;
    fetch copy_cursor_groups into aid;
end while;

close copy_cursor_groups;
 end 
go
GO


drop procedure if exists groups_logger
go

create procedure groups_logger /*группы*/ (
 acursession varchar(38),
 agroupsid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists groupuser_logger
go

create procedure groupuser_logger /*состав группы*/ (
 acursession varchar(38),
 agroupuserid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists groups_parent
go
create procedure groups_parent /* группы*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from groups where  groupsid=arowid;
 end 
go
GO


drop procedure if exists groups_islocked
go
create procedure groups_islocked /* группы */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from groups where groupsid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists groups_lock
go
create procedure groups_lock /* группы */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call groups_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update groups set lockuserid =auserid ,locksessionid=null  where groupsid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update groups set lockuserid=null ,locksessionid =acursession  where groupsid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists groups_unlock
go
create procedure groups_unlock /* группы */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call groups_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update groups set lockuserid =null  where groupsid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update groups set locksessionid =null  where groupsid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS groups_client_trigger
GO

create procedure groups_client_trigger  (
 acursession varchar(38),
 aGroupsid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists groupuser_parent
go
create procedure groupuser_parent /* состав группы*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from groupuser where  groupuserid=arowid;
  set aparenttable = 'groups';
 end 
go
GO


drop procedure if exists groupuser_islocked
go
create procedure groupuser_islocked /* состав группы */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from groupuser where groupuserid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists groupuser_lock
go
create procedure groupuser_lock /* состав группы */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call groupuser_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update groupuser set lockuserid =auserid ,locksessionid=null  where groupuserid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update groupuser set lockuserid=null ,locksessionid =acursession  where groupuserid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists groupuser_unlock
go
create procedure groupuser_unlock /* состав группы */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call groupuser_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update groupuser set lockuserid =null  where groupuserid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update groupuser set locksessionid =null  where groupuserid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS groupuser_client_trigger
GO

create procedure groupuser_client_trigger  (
 acursession varchar(38),
 aGroupUserid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists bp3dic_gen_brief
go

create procedure bp3dic_gen_brief  (
 acursession varchar(38),
 abp3dic_genid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if abp3dic_genid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from bp3dic_gen where bp3dic_genid=g2b(abp3dic_genid);
 if  aec &gt;0 then
   set abrief=bp3dic_gen_brief_f(g2b(abp3dic_genid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists bp3dic_gen_delete
go

create procedure bp3dic_gen_delete /*генераторы*/ (
 acursession varchar(38),
 abp3dic_genid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3dic_gen where bp3dic_genid=g2b(abp3dic_genid);
if aec&gt;0 then
 select checkoperation( acursession ,'bp3dic.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=bp3dic_gen' result;
    leave body;
  end if;
 call bp3dic_gen_logger(acursession,abp3dic_genid) ; 
  delete from  bp3dic_gen 
  where  bp3dic_genid = g2b(abp3dic_genid) ;
  delete from num_values where ownerpartname='bp3dic_gen' and ownerrowid=g2b(abp3dic_genid);
  end if;
    select 'ok' result;
 end 
go
GO

/*генераторы*/

drop procedure if exists bp3dic_gen_save
go

create procedure bp3dic_gen_save /*генераторы*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 abp3dic_genid varchar(38)
,aname
 varchar (255)/* название *//* название */
,ageneratorstyle
 integer/* вариант *//* вариант */
,aqueuename
 varchar (255)/* очередь *//* очередь */
,athedevelopmentenv
 integer/* среда разработки *//* среда разработки */
,ageneratorprogid
 varchar (255)/* com класс *//* com класс */
,atargettype
 integer/* тип платформы *//* тип платформы */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3dic_gen where bp3dic_genid=g2b(abp3dic_genid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'bp3dic.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=bp3dic_gen' result;
    leave body;
  end if;
 start transaction ; 
 call bp3dic_gen_logger(acursession,abp3dic_genid) ; 
 update  bp3dic_gen set changestamp=now()
,
  name=aname
,
  generatorstyle=ageneratorstyle
,
  queuename=aqueuename
,
  thedevelopmentenv=athedevelopmentenv
,
  generatorprogid=ageneratorprogid
,
  targettype=atargettype
  where  bp3dic_genid = g2b(abp3dic_genid) ;


call bp3dic_gen_client_trigger(acursession,abp3dic_genid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'bp3dic.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=bp3dic_gen' result;
    leave body;
  end if;
 start transaction;  
 insert into   bp3dic_gen
 (  bp3dic_genid 
,instanceid
,name

,generatorstyle

,queuename

,thedevelopmentenv

,generatorprogid

,targettype

 ) values ( g2b(abp3dic_genid) 
,g2b(ainstanceid)
,aname

,ageneratorstyle

,aqueuename

,athedevelopmentenv

,ageneratorprogid

,atargettype

 ) ;


call bp3dic_gen_client_trigger(acursession,abp3dic_genid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists bp3dic_gen_copy
go

create procedure bp3dic_gen_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into bp3dic_gen 
 ( bp3dic_genid 
,instanceid
,name

,generatorstyle

,queuename

,thedevelopmentenv

,generatorprogid

,targettype

 ) select 
copymap(acopyaction,b2g(bp3dic_genid)) 
,copymap(acopyaction,b2g(instanceid))
,name

,generatorstyle

,queuename

,thedevelopmentenv

,generatorprogid

,targettype

 from bp3dic_gen
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists bp3dic_gen_logger
go

create procedure bp3dic_gen_logger /*генераторы*/ (
 acursession varchar(38),
 abp3dic_genid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists bp3dic_gen_parent
go
create procedure bp3dic_gen_parent /* генераторы*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from bp3dic_gen where  bp3dic_genid=arowid;
 end 
go
GO


drop procedure if exists bp3dic_gen_islocked
go
create procedure bp3dic_gen_islocked /* генераторы */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from bp3dic_gen where bp3dic_genid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists bp3dic_gen_lock
go
create procedure bp3dic_gen_lock /* генераторы */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call bp3dic_gen_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update bp3dic_gen set lockuserid =auserid ,locksessionid=null  where bp3dic_genid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update bp3dic_gen set lockuserid=null ,locksessionid =acursession  where bp3dic_genid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists bp3dic_gen_unlock
go
create procedure bp3dic_gen_unlock /* генераторы */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call bp3dic_gen_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update bp3dic_gen set lockuserid =null  where bp3dic_genid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update bp3dic_gen set locksessionid =null  where bp3dic_genid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS bp3dic_gen_client_trigger
GO

create procedure bp3dic_gen_client_trigger  (
 acursession varchar(38),
 abp3dic_genid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists bp3card_part_brief
go

create procedure bp3card_part_brief  (
 acursession varchar(38),
 abp3card_partid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if abp3card_partid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from bp3card_part where bp3card_partid=g2b(abp3card_partid);
 if  aec &gt;0 then
   set abrief=bp3card_part_brief_f(g2b(abp3card_partid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists bp3card_part_delete
go

create procedure bp3card_part_delete /*разделы документа*/ (
 acursession varchar(38),
 abp3card_partid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3card_part where bp3card_partid=g2b(abp3card_partid);
if aec&gt;0 then
 select checkoperation( acursession ,'bp3card.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=bp3card_part' result;
    leave body;
  end if;
 call bp3card_part_logger(acursession,abp3card_partid) ; 
  delete from  bp3card_part 
  where  bp3card_partid = g2b(abp3card_partid) ;
  delete from num_values where ownerpartname='bp3card_part' and ownerrowid=g2b(abp3card_partid);
  end if;
    select 'ok' result;
 end 
go
GO

/*раздел*/

drop procedure if exists bp3card_part_save
go

create procedure bp3card_part_save /*разделы документа*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 abp3card_partid varchar(38)
,aallowadd
 integer/* разрешено добавлять *//* разрешено добавлять */
,aallowdelete
 integer/* разрешено удалять *//* разрешено удалять */
,aallowread
 integer/* разрешен просмотр *//* разрешен просмотр */
,astruct varchar(38)/* структура, доступ к которой ограничен *//* структура, доступ к которой ограничен */
,aallowedit
 integer/* разрешено изменять *//* разрешено изменять */
,asequence
 integer/* № п/п *//* № п/п */
,acaption
 varchar (255)/* заголовок *//* заголовок */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3card_part where bp3card_partid=g2b(abp3card_partid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'bp3card.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=bp3card_part' result;
    leave body;
  end if;
 start transaction ; 
 call bp3card_part_logger(acursession,abp3card_partid) ; 
 update  bp3card_part set changestamp=now()
,
  allowadd=aallowadd
,
  allowdelete=aallowdelete
,
  allowread=aallowread
,
  struct=g2b(astruct)
,
  allowedit=aallowedit
,
  sequence=asequence
,
  caption=acaption
  where  bp3card_partid = g2b(abp3card_partid) ;


call bp3card_part_client_trigger(acursession,abp3card_partid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'bp3card.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=bp3card_part' result;
    leave body;
  end if;
 start transaction;  
 insert into   bp3card_part
 (  bp3card_partid 
,instanceid
,allowadd

,allowdelete

,allowread

,struct

,allowedit

,sequence

,caption

 ) values ( g2b(abp3card_partid) 
,g2b(ainstanceid)
,aallowadd

,aallowdelete

,aallowread

,g2b(astruct)

,aallowedit

,asequence

,acaption

 ) ;


call bp3card_part_client_trigger(acursession,abp3card_partid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists bp3card_part_copy
go

create procedure bp3card_part_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into bp3card_part 
 ( bp3card_partid 
,instanceid
,allowadd

,allowdelete

,allowread

,struct

,allowedit

,sequence

,caption

 ) select 
copymap(acopyaction,b2g(bp3card_partid)) 
,copymap(acopyaction,b2g(instanceid))
,allowadd

,allowdelete

,allowread

,struct

,allowedit

,sequence

,caption

 from bp3card_part
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists bp3card_part_logger
go

create procedure bp3card_part_logger /*разделы документа*/ (
 acursession varchar(38),
 abp3card_partid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists bp3card_part_parent
go
create procedure bp3card_part_parent /* разделы документа*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from bp3card_part where  bp3card_partid=arowid;
 end 
go
GO


drop procedure if exists bp3card_part_islocked
go
create procedure bp3card_part_islocked /* разделы документа */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from bp3card_part where bp3card_partid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists bp3card_part_lock
go
create procedure bp3card_part_lock /* разделы документа */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call bp3card_part_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update bp3card_part set lockuserid =auserid ,locksessionid=null  where bp3card_partid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update bp3card_part set lockuserid=null ,locksessionid =acursession  where bp3card_partid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists bp3card_part_unlock
go
create procedure bp3card_part_unlock /* разделы документа */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call bp3card_part_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update bp3card_part set lockuserid =null  where bp3card_partid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update bp3card_part set locksessionid =null  where bp3card_partid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS bp3card_part_client_trigger
GO

create procedure bp3card_part_client_trigger  (
 acursession varchar(38),
 abp3card_partid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists bp3card_fld_brief
go

create procedure bp3card_fld_brief  (
 acursession varchar(38),
 abp3card_fldid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if abp3card_fldid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from bp3card_fld where bp3card_fldid=g2b(abp3card_fldid);
 if  aec &gt;0 then
   set abrief=bp3card_fld_brief_f(g2b(abp3card_fldid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists bp3card_fld_delete
go

create procedure bp3card_fld_delete /*поля раздела*/ (
 acursession varchar(38),
 abp3card_fldid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3card_fld where bp3card_fldid=g2b(abp3card_fldid);
if aec&gt;0 then
 select checkoperation( acursession ,'bp3card.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=bp3card_fld' result;
    leave body;
  end if;
 call bp3card_fld_logger(acursession,abp3card_fldid) ; 
  delete from  bp3card_fld 
  where  bp3card_fldid = g2b(abp3card_fldid) ;
  delete from num_values where ownerpartname='bp3card_fld' and ownerrowid=g2b(abp3card_fldid);
  end if;
    select 'ok' result;
 end 
go
GO

/*поля карточки*/

drop procedure if exists bp3card_fld_save
go

create procedure bp3card_fld_save /*поля раздела*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 abp3card_fldid varchar(38)
,asequence
 integer/* № п/п *//* № п/п */
,amandatoryfield
 integer/* обязательное поле *//* обязательное поле */
,athefield varchar(38)/* поле, на которое накладывается ограничение *//* поле, на которое накладывается ограничение */
,athepart varchar(38)/* структура, которой принадлежит поле *//* структура, которой принадлежит поле */
,aallowmodify
 integer/* разрешена модификация *//* разрешена модификация */
,aallowread
 integer/* разрешен просмотр *//* разрешен просмотр */
,atabname
 varchar (60)/* имя вкладки *//* имя вкладки */
,afieldgroupbox
 varchar (60)/* имя группы *//* имя группы */
,athestyle
 varchar (50)/* стиль *//* стиль */
,acaption
 varchar (80)/* надпись *//* надпись */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3card_fld where bp3card_fldid=g2b(abp3card_fldid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'bp3card.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=bp3card_fld' result;
    leave body;
  end if;
 start transaction ; 
 call bp3card_fld_logger(acursession,abp3card_fldid) ; 
 update  bp3card_fld set changestamp=now()
,
  sequence=asequence
,
  mandatoryfield=amandatoryfield
,
  thefield=g2b(athefield)
,
  thepart=g2b(athepart)
,
  allowmodify=aallowmodify
,
  allowread=aallowread
,
  tabname=atabname
,
  fieldgroupbox=afieldgroupbox
,
  thestyle=athestyle
,
  caption=acaption
  where  bp3card_fldid = g2b(abp3card_fldid) ;


call bp3card_fld_client_trigger(acursession,abp3card_fldid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'bp3card.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=bp3card_fld' result;
    leave body;
  end if;
 start transaction;  
 insert into   bp3card_fld
 (  bp3card_fldid 
,instanceid
,sequence

,mandatoryfield

,thefield

,thepart

,allowmodify

,allowread

,tabname

,fieldgroupbox

,thestyle

,caption

 ) values ( g2b(abp3card_fldid) 
,g2b(ainstanceid)
,asequence

,amandatoryfield

,g2b(athefield)

,g2b(athepart)

,aallowmodify

,aallowread

,atabname

,afieldgroupbox

,athestyle

,acaption

 ) ;


call bp3card_fld_client_trigger(acursession,abp3card_fldid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists bp3card_fld_copy
go

create procedure bp3card_fld_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into bp3card_fld 
 ( bp3card_fldid 
,instanceid
,sequence

,mandatoryfield

,thefield

,thepart

,allowmodify

,allowread

,tabname

,fieldgroupbox

,thestyle

,caption

 ) select 
copymap(acopyaction,b2g(bp3card_fldid)) 
,copymap(acopyaction,b2g(instanceid))
,sequence

,mandatoryfield

,thefield

,thepart

,allowmodify

,allowread

,tabname

,fieldgroupbox

,thestyle

,caption

 from bp3card_fld
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists bp3card_fld_logger
go

create procedure bp3card_fld_logger /*поля раздела*/ (
 acursession varchar(38),
 abp3card_fldid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists bp3card_fld_parent
go
create procedure bp3card_fld_parent /* поля раздела*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from bp3card_fld where  bp3card_fldid=arowid;
 end 
go
GO


drop procedure if exists bp3card_fld_islocked
go
create procedure bp3card_fld_islocked /* поля раздела */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from bp3card_fld where bp3card_fldid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists bp3card_fld_lock
go
create procedure bp3card_fld_lock /* поля раздела */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call bp3card_fld_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update bp3card_fld set lockuserid =auserid ,locksessionid=null  where bp3card_fldid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update bp3card_fld set lockuserid=null ,locksessionid =acursession  where bp3card_fldid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists bp3card_fld_unlock
go
create procedure bp3card_fld_unlock /* поля раздела */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call bp3card_fld_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update bp3card_fld set lockuserid =null  where bp3card_fldid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update bp3card_fld set locksessionid =null  where bp3card_fldid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS bp3card_fld_client_trigger
GO

create procedure bp3card_fld_client_trigger  (
 acursession varchar(38),
 abp3card_fldid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists bp3card_def_brief
go

create procedure bp3card_def_brief  (
 acursession varchar(38),
 abp3card_defid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if abp3card_defid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from bp3card_def where bp3card_defid=g2b(abp3card_defid);
 if  aec &gt;0 then
   set abrief=bp3card_def_brief_f(g2b(abp3card_defid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists bp3card_def_delete
go

create procedure bp3card_def_delete /*карточка документа*/ (
 acursession varchar(38),
 abp3card_defid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3card_def where bp3card_defid=g2b(abp3card_defid);
if aec&gt;0 then
 select checkoperation( acursession ,'bp3card.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=bp3card_def' result;
    leave body;
  end if;
 call bp3card_def_logger(acursession,abp3card_defid) ; 
  delete from  bp3card_def 
  where  bp3card_defid = g2b(abp3card_defid) ;
  delete from num_values where ownerpartname='bp3card_def' and ownerrowid=g2b(abp3card_defid);
  end if;
    select 'ok' result;
 end 
go
GO

/*карточка документа*/

drop procedure if exists bp3card_def_save
go

create procedure bp3card_def_save /*карточка документа*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 abp3card_defid varchar(38)
,acardfor varchar(38)/* документ *//* документ */
,athecomment
 text/* описание *//* описание */
,aname
 varchar (5)/* название режима *//* название режима */
,adefaultmode
 integer/* этот режим является основным режимом работы объекта *//* этот режим является основным режимом работы объекта */
,acardiconcls
 varchar (1)/* иконка карточки *//* иконка карточки */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3card_def where bp3card_defid=g2b(abp3card_defid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'bp3card.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=bp3card_def' result;
    leave body;
  end if;
 start transaction ; 
 call bp3card_def_logger(acursession,abp3card_defid) ; 
 update  bp3card_def set changestamp=now()
,
  cardfor=g2b(acardfor)
,
  thecomment=athecomment
,
  name=aname
,
  defaultmode=adefaultmode
,
  cardiconcls=acardiconcls
  where  bp3card_defid = g2b(abp3card_defid) ;


call bp3card_def_client_trigger(acursession,abp3card_defid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'bp3card.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=bp3card_def' result;
    leave body;
  end if;
 start transaction;  
 insert into   bp3card_def
 (  bp3card_defid 
,instanceid
,cardfor

,thecomment

,name

,defaultmode

,cardiconcls

 ) values ( g2b(abp3card_defid) 
,g2b(ainstanceid)
,g2b(acardfor)

,athecomment

,aname

,adefaultmode

,acardiconcls

 ) ;


call bp3card_def_client_trigger(acursession,abp3card_defid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists bp3card_def_copy
go

create procedure bp3card_def_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into bp3card_def 
 ( bp3card_defid 
,instanceid
,cardfor

,thecomment

,name

,defaultmode

,cardiconcls

 ) select 
copymap(acopyaction,b2g(bp3card_defid)) 
,copymap(acopyaction,b2g(instanceid))
,cardfor

,thecomment

,name

,defaultmode

,cardiconcls

 from bp3card_def
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists bp3card_def_logger
go

create procedure bp3card_def_logger /*карточка документа*/ (
 acursession varchar(38),
 abp3card_defid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists bp3card_def_parent
go
create procedure bp3card_def_parent /* карточка документа*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from bp3card_def where  bp3card_defid=arowid;
 end 
go
GO


drop procedure if exists bp3card_def_islocked
go
create procedure bp3card_def_islocked /* карточка документа */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from bp3card_def where bp3card_defid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists bp3card_def_lock
go
create procedure bp3card_def_lock /* карточка документа */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call bp3card_def_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update bp3card_def set lockuserid =auserid ,locksessionid=null  where bp3card_defid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update bp3card_def set lockuserid=null ,locksessionid =acursession  where bp3card_defid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists bp3card_def_unlock
go
create procedure bp3card_def_unlock /* карточка документа */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call bp3card_def_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update bp3card_def set lockuserid =null  where bp3card_defid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update bp3card_def set locksessionid =null  where bp3card_defid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS bp3card_def_client_trigger
GO

create procedure bp3card_def_client_trigger  (
 acursession varchar(38),
 abp3card_defid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists bp3doc_uk_brief
go

create procedure bp3doc_uk_brief  (
 acursession varchar(38),
 abp3doc_ukid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if abp3doc_ukid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from bp3doc_uk where bp3doc_ukid=g2b(abp3doc_ukid);
 if  aec &gt;0 then
   set abrief=bp3doc_uk_brief_f(g2b(abp3doc_ukid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists bp3doc_uk_delete
go

create procedure bp3doc_uk_delete /*ограничение уникальности*/ (
 acursession varchar(38),
 abp3doc_ukid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3doc_uk where bp3doc_ukid=g2b(abp3doc_ukid);
if aec&gt;0 then
 select checkoperation( acursession ,'bp3doc.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=bp3doc_uk' result;
    leave body;
  end if;
 call bp3doc_uk_logger(acursession,abp3doc_ukid) ; 
  delete from  bp3doc_uk 
  where  bp3doc_ukid = g2b(abp3doc_ukid) ;
  delete from num_values where ownerpartname='bp3doc_uk' and ownerrowid=g2b(abp3doc_ukid);
  end if;
    select 'ok' result;
 end 
go
GO

/*ограничение уникальности*/

drop procedure if exists bp3doc_uk_save
go

create procedure bp3doc_uk_save /*ограничение уникальности*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 abp3doc_ukid varchar(38)
,athecomment
 text/* описание *//* описание */
,aname
 varchar (80)/* название *//* название */
,aperparent
 integer/* по родителю *//* по родителю */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3doc_uk where bp3doc_ukid=g2b(abp3doc_ukid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'bp3doc.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=bp3doc_uk' result;
    leave body;
  end if;
 start transaction ; 
 call bp3doc_uk_logger(acursession,abp3doc_ukid) ; 
 update  bp3doc_uk set changestamp=now()
,
  thecomment=athecomment
,
  name=aname
,
  perparent=aperparent
  where  bp3doc_ukid = g2b(abp3doc_ukid) ;


call bp3doc_uk_client_trigger(acursession,abp3doc_ukid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'bp3doc.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=bp3doc_uk' result;
    leave body;
  end if;
 start transaction;  
 insert into   bp3doc_uk
 (  bp3doc_ukid 
,instanceid
,thecomment

,name

,perparent

 ) values ( g2b(abp3doc_ukid) 
,g2b(ainstanceid)
,athecomment

,aname

,aperparent

 ) ;


call bp3doc_uk_client_trigger(acursession,abp3doc_ukid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists bp3doc_ukfld_brief
go

create procedure bp3doc_ukfld_brief  (
 acursession varchar(38),
 abp3doc_ukfldid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if abp3doc_ukfldid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from bp3doc_ukfld where bp3doc_ukfldid=g2b(abp3doc_ukfldid);
 if  aec &gt;0 then
   set abrief=bp3doc_ukfld_brief_f(g2b(abp3doc_ukfldid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists bp3doc_ukfld_delete
go

create procedure bp3doc_ukfld_delete /*поля ограничения*/ (
 acursession varchar(38),
 abp3doc_ukfldid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3doc_ukfld where bp3doc_ukfldid=g2b(abp3doc_ukfldid);
if aec&gt;0 then
 select checkoperation( acursession ,'bp3doc.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=bp3doc_ukfld' result;
    leave body;
  end if;
 call bp3doc_ukfld_logger(acursession,abp3doc_ukfldid) ; 
  delete from  bp3doc_ukfld 
  where  bp3doc_ukfldid = g2b(abp3doc_ukfldid) ;
  delete from num_values where ownerpartname='bp3doc_ukfld' and ownerrowid=g2b(abp3doc_ukfldid);
  end if;
    select 'ok' result;
 end 
go
GO

/*поля ограничения*/

drop procedure if exists bp3doc_ukfld_save
go

create procedure bp3doc_ukfld_save /*поля ограничения*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 abp3doc_ukfldid varchar(38)
,athefield varchar(38)/* поле *//* поле */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3doc_ukfld where bp3doc_ukfldid=g2b(abp3doc_ukfldid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'bp3doc.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=bp3doc_ukfld' result;
    leave body;
  end if;
 start transaction ; 
 call bp3doc_ukfld_logger(acursession,abp3doc_ukfldid) ; 
 update  bp3doc_ukfld set changestamp=now()
,
  thefield=g2b(athefield)
  where  bp3doc_ukfldid = g2b(abp3doc_ukfldid) ;


call bp3doc_ukfld_client_trigger(acursession,abp3doc_ukfldid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'bp3doc.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=bp3doc_ukfld' result;
    leave body;
  end if;
 start transaction;  
 insert into   bp3doc_ukfld
 (  bp3doc_ukfldid 
,parentstructrowid
,thefield

 ) values ( g2b(abp3doc_ukfldid) 
,g2b(aparentstructrowid)
,g2b(athefield)

 ) ;


call bp3doc_ukfld_client_trigger(acursession,abp3doc_ukfldid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists bp3doc_ukfld_copy
go

create procedure bp3doc_ukfld_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into bp3doc_ukfld 
 ( bp3doc_ukfldid 
,parentstructrowid
,thefield

 ) select 
copymap(acopyaction,b2g(bp3doc_ukfldid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,thefield

 from bp3doc_ukfld
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists bp3doc_uk_copy
go

create procedure bp3doc_uk_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
declare aid binary(16);
declare fetch_done int default false;
declare copy_cursor_bp3doc_uk cursor for
select bp3doc_ukid from bp3doc_uk where 
instanceid =ainstanceid;
 declare continue handler for not found set fetch_done = true;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into bp3doc_uk 
 ( bp3doc_ukid 
,instanceid
,thecomment

,name

,perparent

 ) select 
copymap(acopyaction,b2g(bp3doc_ukid)) 
,copymap(acopyaction,b2g(instanceid))
,thecomment

,name

,perparent

 from bp3doc_uk
 where instanceid =g2b( ainstanceid); 
open copy_cursor_bp3doc_uk;
  set  fetch_done=false;
fetch copy_cursor_bp3doc_uk into aid;
while not fetch_done do 
    call bp3doc_ukfld_copy(acursession,acopyaction,ainstanceid,aid);
  set  fetch_done=false;
    fetch copy_cursor_bp3doc_uk into aid;
end while;

close copy_cursor_bp3doc_uk;
 end 
go
GO


drop procedure if exists bp3doc_uk_logger
go

create procedure bp3doc_uk_logger /*ограничение уникальности*/ (
 acursession varchar(38),
 abp3doc_ukid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists bp3doc_ukfld_logger
go

create procedure bp3doc_ukfld_logger /*поля ограничения*/ (
 acursession varchar(38),
 abp3doc_ukfldid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists bp3doc_uk_parent
go
create procedure bp3doc_uk_parent /* ограничение уникальности*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from bp3doc_uk where  bp3doc_ukid=arowid;
 end 
go
GO


drop procedure if exists bp3doc_uk_islocked
go
create procedure bp3doc_uk_islocked /* ограничение уникальности */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from bp3doc_uk where bp3doc_ukid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists bp3doc_uk_lock
go
create procedure bp3doc_uk_lock /* ограничение уникальности */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call bp3doc_uk_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update bp3doc_uk set lockuserid =auserid ,locksessionid=null  where bp3doc_ukid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update bp3doc_uk set lockuserid=null ,locksessionid =acursession  where bp3doc_ukid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists bp3doc_uk_unlock
go
create procedure bp3doc_uk_unlock /* ограничение уникальности */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call bp3doc_uk_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update bp3doc_uk set lockuserid =null  where bp3doc_ukid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update bp3doc_uk set locksessionid =null  where bp3doc_ukid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS bp3doc_uk_client_trigger
GO

create procedure bp3doc_uk_client_trigger  (
 acursession varchar(38),
 abp3doc_ukid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists bp3doc_ukfld_parent
go
create procedure bp3doc_ukfld_parent /* поля ограничения*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from bp3doc_ukfld where  bp3doc_ukfldid=arowid;
  set aparenttable = 'bp3doc_uk';
 end 
go
GO


drop procedure if exists bp3doc_ukfld_islocked
go
create procedure bp3doc_ukfld_islocked /* поля ограничения */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from bp3doc_ukfld where bp3doc_ukfldid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists bp3doc_ukfld_lock
go
create procedure bp3doc_ukfld_lock /* поля ограничения */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call bp3doc_ukfld_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update bp3doc_ukfld set lockuserid =auserid ,locksessionid=null  where bp3doc_ukfldid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update bp3doc_ukfld set lockuserid=null ,locksessionid =acursession  where bp3doc_ukfldid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists bp3doc_ukfld_unlock
go
create procedure bp3doc_ukfld_unlock /* поля ограничения */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call bp3doc_ukfld_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update bp3doc_ukfld set lockuserid =null  where bp3doc_ukfldid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update bp3doc_ukfld set locksessionid =null  where bp3doc_ukfldid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS bp3doc_ukfld_client_trigger
GO

create procedure bp3doc_ukfld_client_trigger  (
 acursession varchar(38),
 abp3doc_ukfldid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists bp3doc_store_brief
go

create procedure bp3doc_store_brief  (
 acursession varchar(38),
 abp3doc_storeid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if abp3doc_storeid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from bp3doc_store where bp3doc_storeid=g2b(abp3doc_storeid);
 if  aec &gt;0 then
   set abrief=bp3doc_store_brief_f(g2b(abp3doc_storeid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists bp3doc_store_delete
go

create procedure bp3doc_store_delete /*раздел объекта*/ (
 acursession varchar(38),
 abp3doc_storeid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3doc_store where bp3doc_storeid=g2b(abp3doc_storeid);
if aec&gt;0 then
 select checkoperation( acursession ,'bp3doc.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=bp3doc_store' result;
    leave body;
  end if;
 call bp3doc_store_logger(acursession,abp3doc_storeid) ; 
  delete from  bp3doc_store 
  where  bp3doc_storeid = g2b(abp3doc_storeid) ;
  delete from num_values where ownerpartname='bp3doc_store' and ownerrowid=g2b(abp3doc_storeid);
  end if;
    select 'ok' result;
 end 
go
GO

/*раздел*/

drop procedure if exists bp3doc_store_save
go

create procedure bp3doc_store_save /*раздел объекта*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 abp3doc_storeid varchar(38)
,aparentrowid varchar(38) 
,asequence
 integer/* № п/п *//* № п/п */
,acaption
 varchar (255)/* заголовок *//* заголовок */
,aparttype
 integer/* тип структры *//* тип структры */
,aname
 varchar (20)/* название *//* название */
,athe_comment
 text/* описание *//* описание */
,aisdocinstance
 integer/* главный раздел *//* главный раздел */
,ausearchiving
 integer/* архивировать вместо удаления *//* архивировать вместо удаления */
,anolog
 integer/* не записывать в журнал *//* не записывать в журнал */
,ashablonbrief
 varchar (100)/* шаблон для краткого отображения *//* шаблон для краткого отображения */
,ausechangelog
 integer/* вести журнал изменений *//* вести журнал изменений */
,arulebrief
 varchar (500)/* правило составления brief поля *//* правило составления brief поля */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3doc_store where bp3doc_storeid=g2b(abp3doc_storeid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'bp3doc.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=bp3doc_store' result;
    leave body;
  end if;
 start transaction ; 
 call bp3doc_store_logger(acursession,abp3doc_storeid) ; 
 update  bp3doc_store set changestamp=now()
,parentrowid= g2b(aparentrowid)
,
  sequence=asequence
,
  caption=acaption
,
  parttype=aparttype
,
  name=aname
,
  the_comment=athe_comment
,
  isdocinstance=aisdocinstance
,
  usearchiving=ausearchiving
,
  nolog=anolog
,
  shablonbrief=ashablonbrief
,
  usechangelog=ausechangelog
,
  rulebrief=arulebrief
  where  bp3doc_storeid = g2b(abp3doc_storeid) ;


call bp3doc_store_client_trigger(acursession,abp3doc_storeid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'bp3doc.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=bp3doc_store' result;
    leave body;
  end if;
 start transaction;  
 insert into   bp3doc_store
 (  bp3doc_storeid 
,parentrowid
,instanceid
,sequence

,caption

,parttype

,name

,the_comment

,isdocinstance

,usearchiving

,nolog

,shablonbrief

,usechangelog

,rulebrief

 ) values ( g2b(abp3doc_storeid) 
,g2b(aparentrowid)
,g2b(ainstanceid)
,asequence

,acaption

,aparttype

,aname

,athe_comment

,aisdocinstance

,ausearchiving

,anolog

,ashablonbrief

,ausechangelog

,arulebrief

 ) ;


call bp3doc_store_client_trigger(acursession,abp3doc_storeid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists bp3doc_field_brief
go

create procedure bp3doc_field_brief  (
 acursession varchar(38),
 abp3doc_fieldid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if abp3doc_fieldid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from bp3doc_field where bp3doc_fieldid=g2b(abp3doc_fieldid);
 if  aec &gt;0 then
   set abrief=bp3doc_field_brief_f(g2b(abp3doc_fieldid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists bp3doc_field_delete
go

create procedure bp3doc_field_delete /*поле*/ (
 acursession varchar(38),
 abp3doc_fieldid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3doc_field where bp3doc_fieldid=g2b(abp3doc_fieldid);
if aec&gt;0 then
 select checkoperation( acursession ,'bp3doc.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=bp3doc_field' result;
    leave body;
  end if;
 call bp3doc_field_logger(acursession,abp3doc_fieldid) ; 
  delete from  bp3doc_field 
  where  bp3doc_fieldid = g2b(abp3doc_fieldid) ;
  delete from num_values where ownerpartname='bp3doc_field' and ownerrowid=g2b(abp3doc_fieldid);
  end if;
    select 'ok' result;
 end 
go
GO

/*поле*/

drop procedure if exists bp3doc_field_save
go

create procedure bp3doc_field_save /*поле*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 abp3doc_fieldid varchar(38)
,asequence
 integer/* № п/п *//* № п/п */
,aname
 varchar (64)/* имя поля *//* имя поля */
,acaption
 varchar (80)/* надпись *//* надпись */
,atabname
 varchar (60)/* имя вкладки *//* имя вкладки */
,afieldgroupbox
 varchar (60)/* имя группы *//* имя группы */
,aallownull
 integer/* может быть пустым *//* может быть пустым */
,afieldtype varchar(38)/* тип поля *//* тип поля */
,areferencetype
 integer/* тип ссылки *//* тип ссылки */
,adatasize
 integer/* размер поля *//* размер поля */
,areftopart varchar(38)/* ссылка на раздел *//* ссылка на раздел */
,ainternalreference
 integer/* ссылка в пределах объекта *//* ссылка в пределах объекта */
,athecomment
 text/* описание *//* описание */
,aisautonumber
 integer/* автонумерация *//* автонумерация */
,aisbrief
 integer/* краткая информация *//* краткая информация */
,aistabbrief
 integer/* для отображения в таблице *//* для отображения в таблице */
,athestyle
 varchar (50)/* стиль *//* стиль */
,athemask
 varchar (64)/* маска *//* маска */
,ashablonbrief
 varchar (100)/* шаблон для краткого отображения *//* шаблон для краткого отображения */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3doc_field where bp3doc_fieldid=g2b(abp3doc_fieldid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'bp3doc.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=bp3doc_field' result;
    leave body;
  end if;
 start transaction ; 
 call bp3doc_field_logger(acursession,abp3doc_fieldid) ; 
 update  bp3doc_field set changestamp=now()
,
  sequence=asequence
,
  name=aname
,
  caption=acaption
,
  tabname=atabname
,
  fieldgroupbox=afieldgroupbox
,
  allownull=aallownull
,
  fieldtype=g2b(afieldtype)
,
  referencetype=areferencetype
,
  datasize=adatasize
,
  reftopart=g2b(areftopart)
,
  internalreference=ainternalreference
,
  thecomment=athecomment
,
  isautonumber=aisautonumber
,
  isbrief=aisbrief
,
  istabbrief=aistabbrief
,
  thestyle=athestyle
,
  themask=athemask
,
  shablonbrief=ashablonbrief
  where  bp3doc_fieldid = g2b(abp3doc_fieldid) ;


call bp3doc_field_client_trigger(acursession,abp3doc_fieldid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'bp3doc.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=bp3doc_field' result;
    leave body;
  end if;
 start transaction;  
 insert into   bp3doc_field
 (  bp3doc_fieldid 
,parentstructrowid
,sequence

,name

,caption

,tabname

,fieldgroupbox

,allownull

,fieldtype

,referencetype

,datasize

,reftopart

,internalreference

,thecomment

,isautonumber

,isbrief

,istabbrief

,thestyle

,themask

,shablonbrief

 ) values ( g2b(abp3doc_fieldid) 
,g2b(aparentstructrowid)
,asequence

,aname

,acaption

,atabname

,afieldgroupbox

,aallownull

,g2b(afieldtype)

,areferencetype

,adatasize

,g2b(areftopart)

,ainternalreference

,athecomment

,aisautonumber

,aisbrief

,aistabbrief

,athestyle

,athemask

,ashablonbrief

 ) ;


call bp3doc_field_client_trigger(acursession,abp3doc_fieldid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists bp3doc_field_copy
go

create procedure bp3doc_field_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into bp3doc_field 
 ( bp3doc_fieldid 
,parentstructrowid
,sequence

,name

,caption

,tabname

,fieldgroupbox

,allownull

,fieldtype

,referencetype

,datasize

,reftopart

,internalreference

,thecomment

,isautonumber

,isbrief

,istabbrief

,thestyle

,themask

,shablonbrief

 ) select 
copymap(acopyaction,b2g(bp3doc_fieldid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,sequence

,name

,caption

,tabname

,fieldgroupbox

,allownull

,fieldtype

,referencetype

,datasize

,reftopart

,internalreference

,thecomment

,isautonumber

,isbrief

,istabbrief

,thestyle

,themask

,shablonbrief

 from bp3doc_field
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists bp3doc_store_copy
go

create procedure bp3doc_store_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
declare aid binary(16);
declare fetch_done int default false;
declare copy_cursor_bp3doc_store cursor for
select bp3doc_storeid from bp3doc_store where 
instanceid =ainstanceid;
 declare continue handler for not found set fetch_done = true;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into bp3doc_store 
 ( bp3doc_storeid 
,instanceid
,parentrowid
,sequence

,caption

,parttype

,name

,the_comment

,isdocinstance

,usearchiving

,nolog

,shablonbrief

,usechangelog

,rulebrief

 ) select 
copymap(acopyaction,b2g(bp3doc_storeid)) 
,copymap(acopyaction,b2g(instanceid))
,copymap(acopyaction,b2g(parentrowid))
,sequence

,caption

,parttype

,name

,the_comment

,isdocinstance

,usearchiving

,nolog

,shablonbrief

,usechangelog

,rulebrief

 from bp3doc_store
 where instanceid =g2b( ainstanceid); 
open copy_cursor_bp3doc_store;
  set  fetch_done=false;
fetch copy_cursor_bp3doc_store into aid;
while not fetch_done do 
    call bp3doc_field_copy(acursession,acopyaction,ainstanceid,aid);
  set  fetch_done=false;
    fetch copy_cursor_bp3doc_store into aid;
end while;

close copy_cursor_bp3doc_store;
 end 
go
GO


drop procedure if exists bp3doc_store_logger
go

create procedure bp3doc_store_logger /*раздел объекта*/ (
 acursession varchar(38),
 abp3doc_storeid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists bp3doc_field_logger
go

create procedure bp3doc_field_logger /*поле*/ (
 acursession varchar(38),
 abp3doc_fieldid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists bp3doc_store_parent
go
create procedure bp3doc_store_parent /* раздел объекта*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from bp3doc_store where  bp3doc_storeid=arowid;
 end 
go
GO


drop procedure if exists bp3doc_store_islocked
go
create procedure bp3doc_store_islocked /* раздел объекта */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from bp3doc_store where bp3doc_storeid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists bp3doc_store_lock
go
create procedure bp3doc_store_lock /* раздел объекта */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call bp3doc_store_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update bp3doc_store set lockuserid =auserid ,locksessionid=null  where bp3doc_storeid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update bp3doc_store set lockuserid=null ,locksessionid =acursession  where bp3doc_storeid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists bp3doc_store_unlock
go
create procedure bp3doc_store_unlock /* раздел объекта */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call bp3doc_store_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update bp3doc_store set lockuserid =null  where bp3doc_storeid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update bp3doc_store set locksessionid =null  where bp3doc_storeid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS bp3doc_store_client_trigger
GO

create procedure bp3doc_store_client_trigger  (
 acursession varchar(38),
 abp3doc_storeid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists bp3doc_field_parent
go
create procedure bp3doc_field_parent /* поле*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from bp3doc_field where  bp3doc_fieldid=arowid;
  set aparenttable = 'bp3doc_store';
 end 
go
GO


drop procedure if exists bp3doc_field_islocked
go
create procedure bp3doc_field_islocked /* поле */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from bp3doc_field where bp3doc_fieldid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists bp3doc_field_lock
go
create procedure bp3doc_field_lock /* поле */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call bp3doc_field_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update bp3doc_field set lockuserid =auserid ,locksessionid=null  where bp3doc_fieldid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update bp3doc_field set lockuserid=null ,locksessionid =acursession  where bp3doc_fieldid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists bp3doc_field_unlock
go
create procedure bp3doc_field_unlock /* поле */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call bp3doc_field_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update bp3doc_field set lockuserid =null  where bp3doc_fieldid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update bp3doc_field set locksessionid =null  where bp3doc_fieldid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS bp3doc_field_client_trigger
GO

create procedure bp3doc_field_client_trigger  (
 acursession varchar(38),
 abp3doc_fieldid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists bp3doc_def_brief
go

create procedure bp3doc_def_brief  (
 acursession varchar(38),
 abp3doc_defid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if abp3doc_defid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from bp3doc_def where bp3doc_defid=g2b(abp3doc_defid);
 if  aec &gt;0 then
   set abrief=bp3doc_def_brief_f(g2b(abp3doc_defid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists bp3doc_def_delete
go

create procedure bp3doc_def_delete /*описание документа*/ (
 acursession varchar(38),
 abp3doc_defid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3doc_def where bp3doc_defid=g2b(abp3doc_defid);
if aec&gt;0 then
 select checkoperation( acursession ,'bp3doc.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=bp3doc_def' result;
    leave body;
  end if;
 call bp3doc_def_logger(acursession,abp3doc_defid) ; 
  delete from  bp3doc_def 
  where  bp3doc_defid = g2b(abp3doc_defid) ;
  delete from num_values where ownerpartname='bp3doc_def' and ownerrowid=g2b(abp3doc_defid);
  end if;
    select 'ok' result;
 end 
go
GO

/*описание*/

drop procedure if exists bp3doc_def_save
go

create procedure bp3doc_def_save /*описание документа*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 abp3doc_defid varchar(38)
,athecaption
 varchar (255)/* название *//* название */
,aname
 varchar (14)/* код *//* код */
,aissingleinstance
 integer/* допускается только один объект *//* допускается только один объект */
,athecomment
 text/* описание *//* описание */
,auseownership
 integer/* видмость зависит от пользователя *//* видмость зависит от пользователя */
,ausearchiving
 integer/* архивировать вместо удаления *//* архивировать вместо удаления */
,acommitfullobject
 integer/* сохранять объект целиком *//* сохранять объект целиком */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3doc_def where bp3doc_defid=g2b(abp3doc_defid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'bp3doc.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=bp3doc_def' result;
    leave body;
  end if;
 start transaction ; 
 call bp3doc_def_logger(acursession,abp3doc_defid) ; 
 update  bp3doc_def set changestamp=now()
,
  thecaption=athecaption
,
  name=aname
,
  issingleinstance=aissingleinstance
,
  thecomment=athecomment
,
  useownership=auseownership
,
  usearchiving=ausearchiving
,
  commitfullobject=acommitfullobject
  where  bp3doc_defid = g2b(abp3doc_defid) ;


call bp3doc_def_client_trigger(acursession,abp3doc_defid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'bp3doc.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=bp3doc_def' result;
    leave body;
  end if;
select count(*) into aec from bp3doc_def where 
instanceid=g2b(ainstanceid);
if aec &gt;0 then 
    select 'невозможно создать вторую строку в однострочной сессии. раздел: &lt;bp3doc_def&gt;' result;
    rollback;
    leave body;
 end if;
 start transaction;  
 insert into   bp3doc_def
 (  bp3doc_defid 
,instanceid
,thecaption

,name

,issingleinstance

,thecomment

,useownership

,usearchiving

,commitfullobject

 ) values ( g2b(abp3doc_defid) 
,g2b(ainstanceid)
,athecaption

,aname

,aissingleinstance

,athecomment

,auseownership

,ausearchiving

,acommitfullobject

 ) ;


call bp3doc_def_client_trigger(acursession,abp3doc_defid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists bp3doc_def_copy
go

create procedure bp3doc_def_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into bp3doc_def 
 ( bp3doc_defid 
,instanceid
,thecaption

,name

,issingleinstance

,thecomment

,useownership

,usearchiving

,commitfullobject

 ) select 
copymap(acopyaction,b2g(bp3doc_defid)) 
,copymap(acopyaction,b2g(instanceid))
,thecaption

,name

,issingleinstance

,thecomment

,useownership

,usearchiving

,commitfullobject

 from bp3doc_def
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists bp3doc_def_logger
go

create procedure bp3doc_def_logger /*описание документа*/ (
 acursession varchar(38),
 abp3doc_defid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists bp3doc_def_parent
go
create procedure bp3doc_def_parent /* описание документа*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from bp3doc_def where  bp3doc_defid=arowid;
 end 
go
GO


drop procedure if exists bp3doc_def_islocked
go
create procedure bp3doc_def_islocked /* описание документа */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from bp3doc_def where bp3doc_defid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists bp3doc_def_lock
go
create procedure bp3doc_def_lock /* описание документа */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call bp3doc_def_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update bp3doc_def set lockuserid =auserid ,locksessionid=null  where bp3doc_defid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update bp3doc_def set lockuserid=null ,locksessionid =acursession  where bp3doc_defid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists bp3doc_def_unlock
go
create procedure bp3doc_def_unlock /* описание документа */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call bp3doc_def_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update bp3doc_def set lockuserid =null  where bp3doc_defid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update bp3doc_def set locksessionid =null  where bp3doc_defid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS bp3doc_def_client_trigger
GO

create procedure bp3doc_def_client_trigger  (
 acursession varchar(38),
 abp3doc_defid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists bp3report_def_brief
go

create procedure bp3report_def_brief  (
 acursession varchar(38),
 abp3report_defid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if abp3report_defid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from bp3report_def where bp3report_defid=g2b(abp3report_defid);
 if  aec &gt;0 then
   set abrief=bp3report_def_brief_f(g2b(abp3report_defid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists bp3report_def_delete
go

create procedure bp3report_def_delete /*описание*/ (
 acursession varchar(38),
 abp3report_defid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3report_def where bp3report_defid=g2b(abp3report_defid);
if aec&gt;0 then
 select checkoperation( acursession ,'bp3report.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=bp3report_def' result;
    leave body;
  end if;
 call bp3report_def_logger(acursession,abp3report_defid) ; 
  delete from  bp3report_def 
  where  bp3report_defid = g2b(abp3report_defid) ;
  delete from num_values where ownerpartname='bp3report_def' and ownerrowid=g2b(abp3report_defid);
  end if;
    select 'ok' result;
 end 
go
GO

/*описание*/

drop procedure if exists bp3report_def_save
go

create procedure bp3report_def_save /*описание*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 abp3report_defid varchar(38)
,acaption
 varchar (255)/* заголовок *//* заголовок */
,areporttype
 integer/* тип отчета *//* тип отчета */
,athecomment
 text/* описание *//* описание */
,areportfile
 mediumblob/* файл отчета */
,areportfile_ext varchar(4) /* файл отчета */
,aname
 varchar (255)/* название *//* название */
,areportview varchar(38)/* базовый запрос *//* базовый запрос */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3report_def where bp3report_defid=g2b(abp3report_defid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'bp3report.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=bp3report_def' result;
    leave body;
  end if;
 start transaction ; 
 call bp3report_def_logger(acursession,abp3report_defid) ; 
 update  bp3report_def set changestamp=now()
,
  caption=acaption
,
  reporttype=areporttype
,
  thecomment=athecomment
,
  reportfile=areportfile
,reportfile_ext=
areportfile_ext 
,
  name=aname
,
  reportview=g2b(areportview)
  where  bp3report_defid = g2b(abp3report_defid) ;


call bp3report_def_client_trigger(acursession,abp3report_defid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'bp3report.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=bp3report_def' result;
    leave body;
  end if;
select count(*) into aec from bp3report_def where 
instanceid=g2b(ainstanceid);
if aec &gt;0 then 
    select 'невозможно создать вторую строку в однострочной сессии. раздел: &lt;bp3report_def&gt;' result;
    rollback;
    leave body;
 end if;
 start transaction;  
 insert into   bp3report_def
 (  bp3report_defid 
,instanceid
,caption

,reporttype

,thecomment

,reportfile

,reportfile_ext
,name

,reportview

 ) values ( g2b(abp3report_defid) 
,g2b(ainstanceid)
,acaption

,areporttype

,athecomment

,areportfile

,areportfile_ext
,aname

,g2b(areportview)

 ) ;


call bp3report_def_client_trigger(acursession,abp3report_defid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists bp3report_def_copy
go

create procedure bp3report_def_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into bp3report_def 
 ( bp3report_defid 
,instanceid
,caption

,reporttype

,thecomment

,reportfile

,reportfile_ext
,name

,reportview

 ) select 
copymap(acopyaction,b2g(bp3report_defid)) 
,copymap(acopyaction,b2g(instanceid))
,caption

,reporttype

,thecomment

,reportfile

,reportfile_ext
,name

,reportview

 from bp3report_def
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists bp3report_def_logger
go

create procedure bp3report_def_logger /*описание*/ (
 acursession varchar(38),
 abp3report_defid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists bp3report_def_parent
go
create procedure bp3report_def_parent /* описание*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from bp3report_def where  bp3report_defid=arowid;
 end 
go
GO


drop procedure if exists bp3report_def_islocked
go
create procedure bp3report_def_islocked /* описание */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from bp3report_def where bp3report_defid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists bp3report_def_lock
go
create procedure bp3report_def_lock /* описание */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call bp3report_def_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update bp3report_def set lockuserid =auserid ,locksessionid=null  where bp3report_defid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update bp3report_def set lockuserid=null ,locksessionid =acursession  where bp3report_defid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists bp3report_def_unlock
go
create procedure bp3report_def_unlock /* описание */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call bp3report_def_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update bp3report_def set lockuserid =null  where bp3report_defid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update bp3report_def set locksessionid =null  where bp3report_defid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS bp3report_def_client_trigger
GO

create procedure bp3report_def_client_trigger  (
 acursession varchar(38),
 abp3report_defid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists bp3report_filter_brief
go

create procedure bp3report_filter_brief  (
 acursession varchar(38),
 abp3report_filterid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if abp3report_filterid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from bp3report_filter where bp3report_filterid=g2b(abp3report_filterid);
 if  aec &gt;0 then
   set abrief=bp3report_filter_brief_f(g2b(abp3report_filterid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists bp3report_filter_delete
go

create procedure bp3report_filter_delete /*фильтр для отчета*/ (
 acursession varchar(38),
 abp3report_filterid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3report_filter where bp3report_filterid=g2b(abp3report_filterid);
if aec&gt;0 then
 select checkoperation( acursession ,'bp3report.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=bp3report_filter' result;
    leave body;
  end if;
 call bp3report_filter_logger(acursession,abp3report_filterid) ; 
  delete from  bp3report_filter 
  where  bp3report_filterid = g2b(abp3report_filterid) ;
  delete from num_values where ownerpartname='bp3report_filter' and ownerrowid=g2b(abp3report_filterid);
  end if;
    select 'ok' result;
 end 
go
GO

/*группа полей фильтра*/

drop procedure if exists bp3report_filter_save
go

create procedure bp3report_filter_save /*фильтр для отчета*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 abp3report_filterid varchar(38)
,aname
 varchar (64)/* название *//* название */
,asequence
 integer/* последовательность *//* последовательность */
,aallowignore
 integer/* можно отключать *//* можно отключать */
,acaption
 varchar (255)/* заголовок *//* заголовок */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3report_filter where bp3report_filterid=g2b(abp3report_filterid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'bp3report.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=bp3report_filter' result;
    leave body;
  end if;
 start transaction ; 
 call bp3report_filter_logger(acursession,abp3report_filterid) ; 
 update  bp3report_filter set changestamp=now()
,
  name=aname
,
  sequence=asequence
,
  allowignore=aallowignore
,
  caption=acaption
  where  bp3report_filterid = g2b(abp3report_filterid) ;


call bp3report_filter_client_trigger(acursession,abp3report_filterid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'bp3report.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=bp3report_filter' result;
    leave body;
  end if;
 start transaction;  
 insert into   bp3report_filter
 (  bp3report_filterid 
,instanceid
,name

,sequence

,allowignore

,caption

 ) values ( g2b(abp3report_filterid) 
,g2b(ainstanceid)
,aname

,asequence

,aallowignore

,acaption

 ) ;


call bp3report_filter_client_trigger(acursession,abp3report_filterid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists bp3report_filterfiel_brief
go

create procedure bp3report_filterfiel_brief  (
 acursession varchar(38),
 abp3report_filterfielid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if abp3report_filterfielid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from bp3report_filterfiel where bp3report_filterfielid=g2b(abp3report_filterfielid);
 if  aec &gt;0 then
   set abrief=bp3report_filterfiel_brief_f(g2b(abp3report_filterfielid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists bp3report_filterfiel_delete
go

create procedure bp3report_filterfiel_delete /*поле фильтра*/ (
 acursession varchar(38),
 abp3report_filterfielid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3report_filterfiel where bp3report_filterfielid=g2b(abp3report_filterfielid);
if aec&gt;0 then
 select checkoperation( acursession ,'bp3report.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=bp3report_filterfiel' result;
    leave body;
  end if;
 call bp3report_filterfiel_logger(acursession,abp3report_filterfielid) ; 
  delete from  bp3report_filterfiel 
  where  bp3report_filterfielid = g2b(abp3report_filterfielid) ;
  delete from num_values where ownerpartname='bp3report_filterfiel' and ownerrowid=g2b(abp3report_filterfielid);
  end if;
    select 'ok' result;
 end 
go
GO

/*поле фильтра*/

drop procedure if exists bp3report_filterfiel_save
go

create procedure bp3report_filterfiel_save /*поле фильтра*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 abp3report_filterfielid varchar(38)
,areftopart varchar(38)/* раздел, куда ссылаемся *//* раздел, куда ссылаемся */
,areftype
 integer/* тип ссылки *//* тип ссылки */
,avaluearray
 integer/* массив значений *//* массив значений */
,asequence
 integer/* последовательность *//* последовательность */
,acaption
 varchar (255)/* заголовок *//* заголовок */
,aname
 varchar (255)/* название *//* название */
,afieldtype varchar(38)/* тип поля *//* тип поля */
,afieldsize
 integer/* размер *//* размер */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from bp3report_filterfiel where bp3report_filterfielid=g2b(abp3report_filterfielid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'bp3report.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=bp3report_filterfiel' result;
    leave body;
  end if;
 start transaction ; 
 call bp3report_filterfiel_logger(acursession,abp3report_filterfielid) ; 
 update  bp3report_filterfiel set changestamp=now()
,
  reftopart=g2b(areftopart)
,
  reftype=areftype
,
  valuearray=avaluearray
,
  sequence=asequence
,
  caption=acaption
,
  name=aname
,
  fieldtype=g2b(afieldtype)
,
  fieldsize=afieldsize
  where  bp3report_filterfielid = g2b(abp3report_filterfielid) ;


call bp3report_filterfiel_client_trigger(acursession,abp3report_filterfielid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'bp3report.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=bp3report_filterfiel' result;
    leave body;
  end if;
 start transaction;  
 insert into   bp3report_filterfiel
 (  bp3report_filterfielid 
,parentstructrowid
,reftopart

,reftype

,valuearray

,sequence

,caption

,name

,fieldtype

,fieldsize

 ) values ( g2b(abp3report_filterfielid) 
,g2b(aparentstructrowid)
,g2b(areftopart)

,areftype

,avaluearray

,asequence

,acaption

,aname

,g2b(afieldtype)

,afieldsize

 ) ;


call bp3report_filterfiel_client_trigger(acursession,abp3report_filterfielid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists bp3report_filterfiel_copy
go

create procedure bp3report_filterfiel_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into bp3report_filterfiel 
 ( bp3report_filterfielid 
,parentstructrowid
,reftopart

,reftype

,valuearray

,sequence

,caption

,name

,fieldtype

,fieldsize

 ) select 
copymap(acopyaction,b2g(bp3report_filterfielid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,reftopart

,reftype

,valuearray

,sequence

,caption

,name

,fieldtype

,fieldsize

 from bp3report_filterfiel
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists bp3report_filter_copy
go

create procedure bp3report_filter_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
declare aid binary(16);
declare fetch_done int default false;
declare copy_cursor_bp3report_filter cursor for
select bp3report_filterid from bp3report_filter where 
instanceid =ainstanceid;
 declare continue handler for not found set fetch_done = true;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into bp3report_filter 
 ( bp3report_filterid 
,instanceid
,name

,sequence

,allowignore

,caption

 ) select 
copymap(acopyaction,b2g(bp3report_filterid)) 
,copymap(acopyaction,b2g(instanceid))
,name

,sequence

,allowignore

,caption

 from bp3report_filter
 where instanceid =g2b( ainstanceid); 
open copy_cursor_bp3report_filter;
  set  fetch_done=false;
fetch copy_cursor_bp3report_filter into aid;
while not fetch_done do 
    call bp3report_filterfiel_copy(acursession,acopyaction,ainstanceid,aid);
  set  fetch_done=false;
    fetch copy_cursor_bp3report_filter into aid;
end while;

close copy_cursor_bp3report_filter;
 end 
go
GO


drop procedure if exists bp3report_filter_logger
go

create procedure bp3report_filter_logger /*фильтр для отчета*/ (
 acursession varchar(38),
 abp3report_filterid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists bp3report_filterfiel_logger
go

create procedure bp3report_filterfiel_logger /*поле фильтра*/ (
 acursession varchar(38),
 abp3report_filterfielid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists bp3report_filter_parent
go
create procedure bp3report_filter_parent /* фильтр для отчета*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from bp3report_filter where  bp3report_filterid=arowid;
 end 
go
GO


drop procedure if exists bp3report_filter_islocked
go
create procedure bp3report_filter_islocked /* фильтр для отчета */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from bp3report_filter where bp3report_filterid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists bp3report_filter_lock
go
create procedure bp3report_filter_lock /* фильтр для отчета */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call bp3report_filter_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update bp3report_filter set lockuserid =auserid ,locksessionid=null  where bp3report_filterid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update bp3report_filter set lockuserid=null ,locksessionid =acursession  where bp3report_filterid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists bp3report_filter_unlock
go
create procedure bp3report_filter_unlock /* фильтр для отчета */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call bp3report_filter_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update bp3report_filter set lockuserid =null  where bp3report_filterid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update bp3report_filter set locksessionid =null  where bp3report_filterid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS bp3report_filter_client_trigger
GO

create procedure bp3report_filter_client_trigger  (
 acursession varchar(38),
 abp3report_filterid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists bp3report_filterfiel_parent
go
create procedure bp3report_filterfiel_parent /* поле фильтра*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from bp3report_filterfiel where  bp3report_filterfielid=arowid;
  set aparenttable = 'bp3report_filter';
 end 
go
GO


drop procedure if exists bp3report_filterfiel_islocked
go
create procedure bp3report_filterfiel_islocked /* поле фильтра */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from bp3report_filterfiel where bp3report_filterfielid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists bp3report_filterfiel_lock
go
create procedure bp3report_filterfiel_lock /* поле фильтра */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call bp3report_filterfiel_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update bp3report_filterfiel set lockuserid =auserid ,locksessionid=null  where bp3report_filterfielid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update bp3report_filterfiel set lockuserid=null ,locksessionid =acursession  where bp3report_filterfielid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists bp3report_filterfiel_unlock
go
create procedure bp3report_filterfiel_unlock /* поле фильтра */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call bp3report_filterfiel_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update bp3report_filterfiel set lockuserid =null  where bp3report_filterfielid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update bp3report_filterfiel set locksessionid =null  where bp3report_filterfielid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS bp3report_filterfiel_client_trigger
GO

create procedure bp3report_filterfiel_client_trigger  (
 acursession varchar(38),
 abp3report_filterfielid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--Methods" BlockCode=" 
">
      <FormData Name="" />
    </BlockHolder>
  </ModuleHolder>
  <ModuleHolder ModuleName="--Kernel views" File="">
    <BlockHolder BlockName="--body" BlockCode=" 


drop view if exists v_instance
go
create view v_instance as
select b2g(`instance`.`instanceid`) as `instanceid`,`instance`.`lockuserid` as `lockuserid`,`instance`.`locksessionid` as `locksessionid`,`instance`.`securitystyleid` as `securitystyleid`,`instance`.`name` as `name`,`instance`.`objtype` as `objtype`,`instance`.`ownerpartname` as `ownerpartname`,`instance`.`ownerrowid` as `ownerrowid`,`instance`.`status` as `status`,`instance`.`archived` as `archived`,`objstatus`.`name` as `statusname`,`objstatus`.`isarchive` as `isarchive` from (`instance` left join `objstatus` on((`instance`.`status` = `objstatus`.`objstatusid`)));
go
">
      <FormData Name="" />
    </BlockHolder>
  </ModuleHolder>
  <ModuleHolder ModuleName="--Views--" File="">
    <BlockHolder BlockName="--Views--" BlockCode=" 
">
      <FormData Name="" />
    </BlockHolder>
  </ModuleHolder>
  <ModuleHolder ModuleName="--Procs" File="">
    <BlockHolder BlockName="--body" BlockCode=" 


drop procedure if exists bp3ft_copy
go

create procedure bp3ft_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call bp3ft_def_copy(acursession,aaction,ainstanceid);
call bp3ft_map_copy(acursession,aaction,ainstanceid);
call bp3ft_enums_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO



drop function if exists bp3ft_access_f
go

create function bp3ft_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists bp3ft_export_f
go

create function bp3ft_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists bp3app_copy
go

create procedure bp3app_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call bp3app_modules_copy(acursession,aaction,ainstanceid);
call bp3app_menu_copy(acursession,aaction,ainstanceid);
call bp3app_rigthtype_copy(acursession,aaction,ainstanceid);
call bp3app_info_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO



drop function if exists bp3app_access_f
go

create function bp3app_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists bp3app_export_f
go

create function bp3app_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists bp3list_copy
go

create procedure bp3list_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call bp3list_col_copy(acursession,aaction,ainstanceid);
call bp3list_def_copy(acursession,aaction,ainstanceid);
call bp3list_filter_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO



drop function if exists bp3list_access_f
go

create function bp3list_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists bp3list_export_f
go

create function bp3list_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists mtzsystem_copy
go

create procedure mtzsystem_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call the_session_copy(acursession,aaction,ainstanceid);
call sysrefcache_copy(acursession,aaction,ainstanceid);
call syslog_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO



drop function if exists mtzsystem_access_f
go

create function mtzsystem_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists mtzsystem_export_f
go

create function mtzsystem_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists bp3qry_copy
go

create procedure bp3qry_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call bp3qry_column_copy(acursession,aaction,ainstanceid);
call bp3qry_def_copy(acursession,aaction,ainstanceid);
call bp3qry_link_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO



drop function if exists bp3qry_access_f
go

create function bp3qry_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists bp3qry_export_f
go

create function bp3qry_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists mtzusers_copy
go

create procedure mtzusers_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call users_copy(acursession,aaction,ainstanceid);
call groups_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO



drop function if exists mtzusers_access_f
go

create function mtzusers_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists mtzusers_export_f
go

create function mtzusers_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists bp3dic_copy
go

create procedure bp3dic_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call bp3dic_gen_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO



drop function if exists bp3dic_access_f
go

create function bp3dic_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists bp3dic_export_f
go

create function bp3dic_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists bp3card_copy
go

create procedure bp3card_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call bp3card_part_copy(acursession,aaction,ainstanceid);
call bp3card_fld_copy(acursession,aaction,ainstanceid);
call bp3card_def_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO



drop function if exists bp3card_access_f
go

create function bp3card_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists bp3card_export_f
go

create function bp3card_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists bp3doc_copy
go

create procedure bp3doc_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call bp3doc_uk_copy(acursession,aaction,ainstanceid);
call bp3doc_store_copy(acursession,aaction,ainstanceid);
call bp3doc_def_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO



drop function if exists bp3doc_access_f
go

create function bp3doc_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists bp3doc_export_f
go

create function bp3doc_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists bp3report_copy
go

create procedure bp3report_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call bp3report_def_copy(acursession,aaction,ainstanceid);
call bp3report_filter_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO



drop function if exists bp3report_access_f
go

create function bp3report_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists bp3report_export_f
go

create function bp3report_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO
">
      <FormData Name="" />
    </BlockHolder>
  </ModuleHolder>
  <ModuleHolder ModuleName="--ManualCode" File="">
    <BlockHolder BlockName="--body" BlockCode=" 
">
      <FormData Name="" />
    </BlockHolder>
  </ModuleHolder>
  <ModuleHolder ModuleName="--Maintains" File="">
    <BlockHolder BlockName="--create" BlockCode=" 
">
      <FormData Name="" />
    </BlockHolder>
  </ModuleHolder>
  <ModuleHolder ModuleName="--Options" File="">
    <BlockHolder BlockName="--Load" BlockCode=" 

drop procedure if exists init;
go
create procedure init() begin
declare aid binary(16);
declare ainstid binary(16);
declare auid binary(16);
declare asession varchar(38);
declare acid binary(16);
declare asecid binary(16);
declare ahid binary(16);
declare atmpstr varchar(255);
declare aec int;
select count(*) into aec from instance where objtype='mtzsystem';
if aec=0 then
    set ainstid = g2b('f5c51225-1944-463a-9b28-d54829287351');
    insert into instance(instanceid,objtype,name,changestamp) values(ainstid, 'mtzsystem','системная информация',now());
else
    select instanceid into ainstid from instance where objtype='mtzsystem';
end if;
set auid = g2b('2601e4d8-efd6-407c-aba1-65cebf3ca38e'); 
set asecid = g2b('baa5fcc8-7315-43cd-b3c5-59cb74c290dd'); 
set ahid = g2b('2d105c22-0070-46d7-bf03-377d0cd990d2'); 
select count(*) into aec from users where usersid=auid;
if aec=0 then
insert into users(usersid,instanceid,login,password) values(auid,null,'init',md5('init'));
end if;
select count(*) into aec from typelist where name='bp3report';
if aec=0 then
insert into typelist(typelistid, name,registerproc,deleteproc, hclproc, propagateproc) values(g2b(uuid()),'bp3report', 'bp3report_register', 'bp3report_delete', 'bp3report_hcl', 'bp3report_propagate');
end if;

set aid = g2b('93f9b2a7-42ae-4e5b-992d-9aaf97cc2ee9');
call sysoptions_save ( b2g(aid), 'bp3ft_def', 'bp3ft', 'struct_type');

set aid = g2b('e89a824c-ea92-4360-96b3-36938282c6ca');
call sysoptions_save ( b2g(aid), 'bp3ft_map', 'bp3ft', 'struct_type');

set aid = g2b('dc63c964-a547-4482-a5cd-3a23392fa30f');
call sysoptions_save ( b2g(aid), 'bp3ft_enums', 'bp3ft', 'struct_type');

set aid = g2b('3aa9c1c7-d81e-4284-a967-cdd7989b9ad3');
call sysoptions_save ( b2g(aid), 'bp3app_modules', 'bp3app', 'struct_type');

set aid = g2b('8e4bcc12-f5e6-40e5-9a17-efbdc9c224e9');
call sysoptions_save ( b2g(aid), 'bp3app_oper', 'bp3app', 'struct_type');
set aid = g2b('9e16b4b2-669f-4fe5-8c96-f87ae93b8233');
call sysoptions_save(  b2g(aid), 'bp3app_oper', 'bp3app_modules', 'parent');

set aid = g2b('540a020a-2652-48cf-a80a-544ecc7a1a24');
call sysoptions_save ( b2g(aid), 'bp3app_menu', 'bp3app', 'struct_type');

set aid = g2b('0f7f7f1e-afe9-4589-8a3b-3468d8f6e166');
call sysoptions_save ( b2g(aid), 'bp3app_rigthtype', 'bp3app', 'struct_type');

set aid = g2b('465ae3c9-a09e-4b26-ad00-04f2f37a7951');
call sysoptions_save ( b2g(aid), 'bp3app_info', 'bp3app', 'struct_type');

set aid = g2b('7be74278-bb5e-44b9-9d28-b6051fd429ed');
call sysoptions_save ( b2g(aid), 'bp3list_col', 'bp3list', 'struct_type');

set aid = g2b('c6dc55d2-c7ea-4d97-bb0b-3a36b6ef9b7b');
call sysoptions_save ( b2g(aid), 'bp3list_colsrc', 'bp3list', 'struct_type');
set aid = g2b('7e811437-99ab-484f-bcd4-dcde75d1839d');
call sysoptions_save(  b2g(aid), 'bp3list_colsrc', 'bp3list_col', 'parent');

set aid = g2b('660a0213-cc86-4738-90f9-051565789fbe');
call sysoptions_save ( b2g(aid), 'bp3list_def', 'bp3list', 'struct_type');

set aid = g2b('fbfc70c0-2485-4b4b-ab55-aa203874f1e9');
call sysoptions_save ( b2g(aid), 'bp3list_filter', 'bp3list', 'struct_type');

set aid = g2b('21dc1919-e6af-4b9e-a3eb-8ec1e1c1dfa7');
call sysoptions_save ( b2g(aid), 'bp3list_filterfield', 'bp3list', 'struct_type');
set aid = g2b('2ac5e4c5-e3ca-46f7-b65a-0b39b0c4e884');
call sysoptions_save(  b2g(aid), 'bp3list_filterfield', 'bp3list_filter', 'parent');

set aid = g2b('f5121dac-8d94-4925-8154-8c344f4ae321');
call sysoptions_save ( b2g(aid), 'the_session', 'mtzsystem', 'struct_type');

set aid = g2b('fad0ed7e-ce60-479f-996a-3e580949b05a');
call sysoptions_save ( b2g(aid), 'sysrefcache', 'mtzsystem', 'struct_type');

set aid = g2b('50e6b51e-aded-42af-9460-30f276e6234a');
call sysoptions_save ( b2g(aid), 'syslog', 'mtzsystem', 'struct_type');

set aid = g2b('c2e12243-3fbb-471e-88cf-0d2b69d1f2b7');
call sysoptions_save ( b2g(aid), 'bp3qry_column', 'bp3qry', 'struct_type');

set aid = g2b('c716fff6-f9e8-42c5-b51b-5b2f0891f60a');
call sysoptions_save ( b2g(aid), 'bp3qry_def', 'bp3qry', 'struct_type');

set aid = g2b('c89a2c54-9d27-4858-a25d-2cea173e0735');
call sysoptions_save ( b2g(aid), 'bp3qry_link', 'bp3qry', 'struct_type');

set aid = g2b('c9b7df67-d68a-4012-9736-7375b9f83141');
call sysoptions_save ( b2g(aid), 'users', 'mtzusers', 'struct_type');

set aid = g2b('5736c688-7c26-44d5-b4e7-b410839582ec');
call sysoptions_save ( b2g(aid), 'groups', 'mtzusers', 'struct_type');

set aid = g2b('d685f097-cd51-4035-a0fc-5d0d55b48d49');
call sysoptions_save ( b2g(aid), 'groupuser', 'mtzusers', 'struct_type');
set aid = g2b('bb3ebfff-6961-453b-aa51-9de140d3ccb9');
call sysoptions_save(  b2g(aid), 'groupuser', 'groups', 'parent');

set aid = g2b('6fafb2c3-2b43-493d-9ea0-25c8f5ff13cd');
call sysoptions_save ( b2g(aid), 'bp3dic_gen', 'bp3dic', 'struct_type');

set aid = g2b('dcc9a748-a857-4806-bdb8-cb26d882620e');
call sysoptions_save ( b2g(aid), 'bp3card_part', 'bp3card', 'struct_type');

set aid = g2b('d5cb23c9-c84e-4862-839f-b56c40705153');
call sysoptions_save ( b2g(aid), 'bp3card_fld', 'bp3card', 'struct_type');

set aid = g2b('32d918b0-eddc-4ce1-82ae-28705d4ba231');
call sysoptions_save ( b2g(aid), 'bp3card_def', 'bp3card', 'struct_type');

set aid = g2b('ccf99395-2ed7-4327-b363-f22b8e9913df');
call sysoptions_save ( b2g(aid), 'bp3doc_uk', 'bp3doc', 'struct_type');

set aid = g2b('363fe9f0-c509-4ead-a8c4-d8dbad1f2a76');
call sysoptions_save ( b2g(aid), 'bp3doc_ukfld', 'bp3doc', 'struct_type');
set aid = g2b('63b2e114-ec38-4619-a8e9-b2f6c57c6faa');
call sysoptions_save(  b2g(aid), 'bp3doc_ukfld', 'bp3doc_uk', 'parent');

set aid = g2b('c5864166-290a-48ea-98f2-d9912c9e9a8b');
call sysoptions_save ( b2g(aid), 'bp3doc_store', 'bp3doc', 'struct_type');

set aid = g2b('b6e5465e-e165-48e7-88c3-fb04f385f533');
call sysoptions_save ( b2g(aid), 'bp3doc_field', 'bp3doc', 'struct_type');
set aid = g2b('e85961e2-09b6-4700-9eb7-ae65c7c91b31');
call sysoptions_save(  b2g(aid), 'bp3doc_field', 'bp3doc_store', 'parent');

set aid = g2b('26bba20a-e984-473f-a8af-41bb344ca430');
call sysoptions_save ( b2g(aid), 'bp3doc_def', 'bp3doc', 'struct_type');

set aid = g2b('7ba433d2-dc8d-454e-924f-387bad18157e');
call sysoptions_save ( b2g(aid), 'bp3report_def', 'bp3report', 'struct_type');

set aid = g2b('dab8ac5b-e1c5-48f3-bc8f-c1ad43156f56');
call sysoptions_save ( b2g(aid), 'bp3report_filter', 'bp3report', 'struct_type');

set aid = g2b('ff351b2f-2ada-4cc7-a505-09001313acf5');
call sysoptions_save ( b2g(aid), 'bp3report_filterfiel', 'bp3report', 'struct_type');
set aid = g2b('145513fa-8762-4dee-b3a4-1b0d21ecc1ac');
call sysoptions_save(  b2g(aid), 'bp3report_filterfiel', 'bp3report_filter', 'parent');

call login( asession  , 'init', 'init');
select count(*) into aec from instance where objtype='mtzusers';
if aec=0 then
   set asecid=g2b('0281c13f-2be3-4cb2-a53f-5683e2e65ea9');
   insert into instance(instanceid,objtype,name) values(asecid, 'mtzusers','пользователи и группы');
else
   select instanceid into asecid from instance where objtype='mtzusers';
end if;
delete from users where login = 'supervisor';
set auid=g2b('e6b39097-e8fd-4802-8118-f5207d4ac4c9');
insert into users(usersid,instanceid,password,login,name,changestamp) values(auid, asecid,  
 md5('bami'),  'supervisor', 'администратор',now());
call logout(asession);
delete from users where login = 'init';
end
go
call init();
go
">
      <FormData Name="" />
    </BlockHolder>
  </ModuleHolder>
</root>